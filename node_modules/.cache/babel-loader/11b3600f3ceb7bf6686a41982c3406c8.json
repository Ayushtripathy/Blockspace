{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\n\nconst nacl = __importStar(require(\"tweetnacl\"));\n\nconst naclUtil = __importStar(require(\"tweetnacl-util\"));\n\nconst utils_1 = require(\"./utils\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\n\n\nfunction encrypt(_ref) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref;\n\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof data !== 'string') {\n          throw new Error('Message data must be given as a string');\n        } // generate ephemeral keypair\n\n\n        const ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n        let pubKeyUInt8Array;\n\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n\n        const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n        const nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        }; // return encrypted msg data\n\n        return output;\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\n\nfunction encryptSafely(_ref2) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref2;\n\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  } // add padding\n\n\n  const dataWithPadding = {\n    data,\n    padding: ''\n  }; // calculate padding\n\n  const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0; // Only pad if necessary\n\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({\n    publicKey,\n    data: paddedMessage,\n    version\n  });\n}\n\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\n\nfunction decrypt(_ref3) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref3;\n\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n        const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n        let output;\n\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n\n        if (output) {\n          return output;\n        }\n\n        throw new Error('Decryption failed.');\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\n\nfunction decryptSafely(_ref4) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref4;\n\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({\n    encryptedData,\n    privateKey\n  }));\n  return dataWithPadding.data;\n}\n\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\n\nfunction getEncryptionPublicKey(privateKey) {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\n\nfunction nacl_decodeHex(msgHex) {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":{"version":3,"sources":["../src/encryption.ts"],"names":[],"mappings":"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","sourcesContent":["import * as nacl from 'tweetnacl';\nimport * as naclUtil from 'tweetnacl-util';\n\nimport { isNullish } from './utils';\n\nexport interface EthEncryptedData {\n  version: string;\n  nonce: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n}\n\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encrypt({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      if (typeof data !== 'string') {\n        throw new Error('Message data must be given as a string');\n      }\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair();\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array;\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n      } catch (err) {\n        throw new Error('Bad public key');\n      }\n\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n      const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey,\n      );\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage),\n      };\n      // return encrypted msg data\n      return output;\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encryptSafely({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error(\n      'Cannot encrypt with toJSON property.  Please remove toJSON property',\n    );\n  }\n\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: '',\n  };\n\n  // calculate padding\n  const dataLength = Buffer.byteLength(\n    JSON.stringify(dataWithPadding),\n    'utf-8',\n  );\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n  dataWithPadding.padding = '0'.repeat(padLength);\n\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({ publicKey, data: paddedMessage, version });\n}\n\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decrypt({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // string to buffer to UInt8Array\n      const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n      const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(\n        recieverPrivateKeyUint8Array,\n      ).secretKey;\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey,\n      );\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey,\n      );\n\n      // return decrypted msg data\n      let output;\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage);\n      } catch (err) {\n        throw new Error('Decryption failed.');\n      }\n\n      if (output) {\n        return output;\n      }\n      throw new Error('Decryption failed.');\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decryptSafely({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n  return dataWithPadding.data;\n}\n\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nexport function getEncryptionPublicKey(privateKey: string): string {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey =\n    nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex: string): Uint8Array {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}