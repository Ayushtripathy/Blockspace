{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, WalletLoginError, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport Common, { Hardfork } from '@ethereumjs/common';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { personalSign, signTypedData, SignTypedDataVersion, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { privateToAddress, stripHexPrefix } from 'ethereumjs-util';\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\n\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\n\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processTypedMessageV4: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state: _objectSpread$1(_objectSpread$1({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId\n    } = _ref2;\n    const currentChainConfig = this.getChainConfig(chainId);\n    const {\n      ticker,\n      tickerName,\n      rpcTarget\n    } = currentChainConfig;\n    this.update({\n      chainId: \"loading\"\n    });\n    await this.connector.updateChain({\n      chainId: Number.parseInt(chainId, 16),\n      nativeCurrency: {\n        name: tickerName,\n        symbol: ticker\n      },\n      networkId: Number.parseInt(chainId, 10),\n      rpcUrl: rpcTarget\n    });\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    await this.lookupNetwork(this.connector);\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = isHexStrict(connectedChainId) ? connectedChainId : \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nasync function getCommonConfiguration(supportsEIP1559, chainConfig) {\n  const {\n    displayName: name,\n    chainId\n  } = chainConfig;\n  const hardfork = supportsEIP1559 ? Hardfork.London : Hardfork.Berlin;\n  const customChainParams = {\n    name,\n    chainId: chainId === \"loading\" ? 0 : parseInt(chainId, 16),\n    networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 10),\n    hardfork\n  };\n  return Common.custom(customChainParams);\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    privKey,\n    chainConfig,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = getProviderHandlers({\n      privKey,\n      chainConfig: this.config.chainConfig,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n    log.debug(\"this provider\", this.provider, chainId, this.state.chainId);\n\n    if (this.state.chainId !== chainId) {\n      this.provider.emit(\"chainChanged\", chainId);\n      this.provider.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };","map":{"version":3,"sources":["../src/rpc/walletMidddleware.ts","../src/rpc/ethRpcMiddlewares.ts","../src/rpc/jrpcClient.ts","../src/providers/injectedProviders/walletConnectUtils.ts","../src/providers/injectedProviders/WalletConnectProvider.ts","../src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","../src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts"],"names":["str","createWalletMiddleware","processTypedMessageV4","address","accounts","getAccounts","normalizedAccounts","_address","normalizedAddress","message","res","ethErrors","txParams","req","from","validateAndNormalizeKeyholder","processTransaction","processSignTransaction","extraParams","msgParams","data","processEthSignMessage","version","processTypedMessage","processTypedMessageV3","firstParam","secondParam","resemblesAddress","warning","processPersonalMessage","processEncryptionPublicKey","ciphertext","processDecryptMessage","getPrivateKey","createScaffoldMiddleware","eth_accounts","createAsyncMiddleware","eth_private_key","eth_coinbase","eth_sendTransaction","eth_signTransaction","eth_sign","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","personal_sign","eth_getEncryptionPublicKey","eth_decrypt","createEthMiddleware","providerHandlers","ethMiddleware","mergeMiddleware","eth_syncing","createChainSwitchMiddleware","switchChain","chainParams","addChain","wallet_addEthereumChain","wallet_switchEthereumChain","createAccountMiddleware","updatePrivatekey","accountParams","wallet_updateAccount","createChainIdMiddleware","chainId","end","next","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","getProviderHandlers","connector","result","log","_","WalletConnectProvider","BaseProvider","constructor","config","chainConfig","chainNamespace","CHAIN_NAMESPACES","EIP155","state","providerFactory","params","enable","code","method","setupProvider","currentChainConfig","Number","nativeCurrency","name","symbol","ticker","networkId","rpcUrl","lookupNetwork","WalletLoginError","connectedHexChainId","isHexStrict","WalletInitializationError","setupEngine","engine","provider","providerFromEngine","onConnectorStateUpdate","connectedChainId","displayName","hardfork","supportsEIP1559","Hardfork","customChainParams","parseInt","Common","getProviderEngineProxy","privateToAddress","Buffer","providerEngineProxy","common","getCommonConfiguration","unsignedEthTx","signedTx","txHash","rawMessageSig","signMessage","privKeyBuffer","sig","personalSign","privateKey","signTypedData","SignTypedDataVersion","V1","V3","V4","getEncryptionPublicKey","stripped","stripHexPrefix","buff","decrypted","decrypt","encryptedData","JSON","privKey","EthereumPrivateKeyProvider","chainSwitchMiddleware","updateAccount","existingKey","network","getChainSwitchMiddleware","chainSwitchHandlers","tickerName","rpcUrls","blockExplorer","getAccountMiddleware","accountHandlers"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, WalletLoginError, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport log from 'loglevel';\nimport Common, { Hardfork } from '@ethereumjs/common';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { personalSign, signTypedData, SignTypedDataVersion, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { privateToAddress, stripHexPrefix } from 'ethereumjs-util';\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$2(_objectSpread$2({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processTypedMessageV4: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state: _objectSpread$1(_objectSpread$1({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId\n    } = _ref2;\n    const currentChainConfig = this.getChainConfig(chainId);\n    const {\n      ticker,\n      tickerName,\n      rpcTarget\n    } = currentChainConfig;\n    this.update({\n      chainId: \"loading\"\n    });\n    await this.connector.updateChain({\n      chainId: Number.parseInt(chainId, 16),\n      nativeCurrency: {\n        name: tickerName,\n        symbol: ticker\n      },\n      networkId: Number.parseInt(chainId, 10),\n      rpcUrl: rpcTarget\n    });\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    await this.lookupNetwork(this.connector);\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = isHexStrict(connectedChainId) ? connectedChainId : \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nasync function getCommonConfiguration(supportsEIP1559, chainConfig) {\n  const {\n    displayName: name,\n    chainId\n  } = chainConfig;\n  const hardfork = supportsEIP1559 ? Hardfork.London : Hardfork.Berlin;\n  const customChainParams = {\n    name,\n    chainId: chainId === \"loading\" ? 0 : parseInt(chainId, 16),\n    networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 10),\n    hardfork\n  };\n  return Common.custom(customChainParams);\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    privKey,\n    chainConfig,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const common = await getCommonConfiguration(!!txParams.maxFeePerGas && !!txParams.maxPriorityFeePerGas, chainConfig);\n      const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n        common\n      });\n      const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = getProviderHandlers({\n      privKey,\n      chainConfig: this.config.chainConfig,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n    log.debug(\"this provider\", this.provider, chainId, this.state.chainId);\n\n    if (this.state.chainId !== chainId) {\n      this.provider.emit(\"chainChanged\", chainId);\n      this.provider.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };\n//# sourceMappingURL=ethereumProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}