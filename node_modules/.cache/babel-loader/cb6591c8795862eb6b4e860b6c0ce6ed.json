{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar PUBLIC_KEY = '*';\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\n\nvar ParseACL = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | object)} arg1 The user to initialize the ACL for\n   */\n  function ParseACL(arg1\n  /*: ParseUser | ByIdMap*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseACL);\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n\n    if (arg1 && (0, _typeof2.default)(arg1) === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (var _userId in arg1) {\n          var accessList = arg1[_userId];\n          this.permissionsById[_userId] = {};\n\n          for (var _permission in accessList) {\n            var allowed = accessList[_permission];\n\n            if (_permission !== 'read' && _permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n\n            this.permissionsById[_userId][_permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseACL, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: ByIdMap*/\n    {\n      var permissions = {};\n\n      for (var p in this.permissionsById) {\n        permissions[p] = this.permissionsById[p];\n      }\n\n      return permissions;\n    }\n    /**\n     * Returns whether this ACL is equal to another object\n     *\n     * @param {ParseACL} other The other object's ACL to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseACL*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseACL)) {\n        return false;\n      }\n\n      var users = (0, _keys.default)(this.permissionsById);\n      var otherUsers = (0, _keys.default)(other.permissionsById);\n\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n\n      for (var u in this.permissionsById) {\n        if (!other.permissionsById[u]) {\n          return false;\n        }\n\n        if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n          return false;\n        }\n\n        if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (accessType\n    /*: string*/\n    , userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n\n        userId = \"role:\".concat(name);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsById[userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        }\n\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n\n      if (allowed) {\n        this.permissionsById[userId][accessType] = true;\n      } else {\n        delete permissions[accessType];\n\n        if ((0, _keys.default)(permissions).length === 0) {\n          delete this.permissionsById[userId];\n        }\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (accessType\n    /*: string*/\n    , userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a ParseUser without an ID');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n\n        userId = \"role:\".concat(name);\n      }\n\n      var permissions = this.permissionsById[userId];\n\n      if (!permissions) {\n        return false;\n      }\n\n      return !!permissions[accessType];\n    }\n    /**\n     * Sets whether the given user is allowed to read this object.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed Whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('read', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read this object.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('read', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write this object.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('write', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write this object.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('write', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read this object.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read this object.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write this object.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write this object.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      return this.getReadAccess(\"role:\".concat(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      return this.getWriteAccess(\"role:\".concat(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      this.setReadAccess(\"role:\".concat(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      this.setWriteAccess(\"role:\".concat(role), allowed);\n    }\n  }]);\n  return ParseACL;\n}();\n\nvar _default = ParseACL;\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/Twitter-Start/node_modules/moralis/lib/browser/ParseACL.js"],"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_keys","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_ParseRole","_ParseUser","PUBLIC_KEY","ParseACL","arg1","permissionsById","setReadAccess","setWriteAccess","_userId","accessList","_permission","allowed","TypeError","key","permissions","p","other","users","otherUsers","length","u","read","write","accessType","userId","id","name","getName","concat","Error","_setAccess","_getAccess","getReadAccess","getWriteAccess","role","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar PUBLIC_KEY = '*';\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\n\nvar ParseACL = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | object)} arg1 The user to initialize the ACL for\n   */\n  function ParseACL(arg1\n  /*: ParseUser | ByIdMap*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseACL);\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n\n    if (arg1 && (0, _typeof2.default)(arg1) === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (var _userId in arg1) {\n          var accessList = arg1[_userId];\n          this.permissionsById[_userId] = {};\n\n          for (var _permission in accessList) {\n            var allowed = accessList[_permission];\n\n            if (_permission !== 'read' && _permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n\n            this.permissionsById[_userId][_permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseACL, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: ByIdMap*/\n    {\n      var permissions = {};\n\n      for (var p in this.permissionsById) {\n        permissions[p] = this.permissionsById[p];\n      }\n\n      return permissions;\n    }\n    /**\n     * Returns whether this ACL is equal to another object\n     *\n     * @param {ParseACL} other The other object's ACL to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseACL*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseACL)) {\n        return false;\n      }\n\n      var users = (0, _keys.default)(this.permissionsById);\n      var otherUsers = (0, _keys.default)(other.permissionsById);\n\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n\n      for (var u in this.permissionsById) {\n        if (!other.permissionsById[u]) {\n          return false;\n        }\n\n        if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n          return false;\n        }\n\n        if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (accessType\n    /*: string*/\n    , userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n\n        userId = \"role:\".concat(name);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsById[userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        }\n\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n\n      if (allowed) {\n        this.permissionsById[userId][accessType] = true;\n      } else {\n        delete permissions[accessType];\n\n        if ((0, _keys.default)(permissions).length === 0) {\n          delete this.permissionsById[userId];\n        }\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (accessType\n    /*: string*/\n    , userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a ParseUser without an ID');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n\n        userId = \"role:\".concat(name);\n      }\n\n      var permissions = this.permissionsById[userId];\n\n      if (!permissions) {\n        return false;\n      }\n\n      return !!permissions[accessType];\n    }\n    /**\n     * Sets whether the given user is allowed to read this object.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed Whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('read', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read this object.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('read', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write this object.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('write', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write this object.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('write', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read this object.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read this object.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write this object.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write this object.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      return this.getReadAccess(\"role:\".concat(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      return this.getWriteAccess(\"role:\".concat(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      this.setReadAccess(\"role:\".concat(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      this.setWriteAccess(\"role:\".concat(role), allowed);\n    }\n  }]);\n  return ParseACL;\n}();\n\nvar _default = ParseACL;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}