{"ast":null,"code":"import loglevel from 'loglevel';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { getPublic, sign, encrypt, decrypt } from '@toruslabs/eccrypto';\nimport { get } from '@toruslabs/http-helpers';\nimport { setupMultiplex, PostMessageStream, SafeEventEmitter, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, getRpcPromiseCallback } from '@toruslabs/openlogin-jrpc';\nimport { base64url, keccak, safeatob, randomId, jsonToBase64 } from '@toruslabs/openlogin-utils';\nimport merge from 'lodash.merge';\nimport pump from 'pump';\nconst modalDOMElementID = \"openlogin-modal\";\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_METHOD = {\n  LOGIN: \"openlogin_login\",\n  LOGOUT: \"openlogin_logout\",\n  CHECK_3PC_SUPPORT: \"openlogin_check_3PC_support\",\n  SET_PID_DATA: \"openlogin_set_pid_data\",\n  GET_DATA: \"openlogin_get_data\"\n};\nconst ALLOWED_INTERACTIONS = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\",\n  JRPC: \"jrpc\"\n};\nconst OPENLOGIN_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  DEVELOPMENT: \"development\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n  WEBAUTHN: \"webauthn\",\n  JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n  DEFAULT: \"default\",\n  OPTIONAL: \"optional\",\n  MANDATORY: \"mandatory\"\n};\nloglevel.setLevel(\"error\");\nvar log = loglevel.getLogger(\"openlogin\");\n\nasync function documentReady() {\n  return new Promise(resolve => {\n    if (document.readyState !== \"loading\") {\n      resolve();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        resolve();\n      });\n    }\n  });\n}\n\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\n\nasync function whitelistUrl(clientId, appKey, origin) {\n  const appKeyBuf = Buffer.from(appKey.padStart(64, \"0\"), \"hex\");\n  if (base64url.encode(getPublic(appKeyBuf)) !== clientId) throw new Error(\"appKey mismatch\");\n  const sig = await sign(appKeyBuf, Buffer.from(keccak(\"keccak256\").update(origin).digest(\"hex\"), \"hex\"));\n  return base64url.encode(sig);\n}\n\nfunction getHashQueryParams() {\n  let replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const result = {};\n  const url = new URL(window.location.href);\n  url.searchParams.forEach((value, key) => {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  const queryResult = url.searchParams.get(\"result\");\n\n  if (queryResult) {\n    try {\n      const queryParams = JSON.parse(safeatob(queryResult));\n      Object.keys(queryParams).forEach(key => {\n        result[key] = queryParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  const hash = url.hash.substring(1);\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash));\n  hashUrl.searchParams.forEach((value, key) => {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  const hashResult = hashUrl.searchParams.get(\"result\");\n\n  if (hashResult) {\n    try {\n      const hashParams = JSON.parse(safeatob(hashResult));\n      Object.keys(hashParams).forEach(key => {\n        result[key] = hashParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  if (replaceUrl) {\n    const cleanUrl = window.location.origin + window.location.pathname;\n    window.history.replaceState(null, \"\", cleanUrl);\n  }\n\n  return result;\n}\n\nfunction awaitReq(id, windowRef) {\n  return new Promise((resolve, reject) => {\n    if (!windowRef) reject(new Error(\"Unable to open window\"));\n    let closedByHandler = false;\n    const closedMonitor = setInterval(() => {\n      if (!closedByHandler && windowRef.closed) {\n        clearInterval(closedMonitor);\n        reject(new Error(\"user closed popup\"));\n      }\n    }, 500);\n\n    const handler = ev => {\n      const {\n        pid\n      } = ev.data;\n      if (id !== pid) return;\n      window.removeEventListener(\"message\", handler);\n      closedByHandler = true;\n      clearInterval(closedMonitor);\n      windowRef.close();\n\n      if (ev.data.data && ev.data.data.error) {\n        reject(new Error(ev.data.data.error));\n      } else {\n        resolve(ev.data.data);\n      }\n    };\n\n    window.addEventListener(\"message\", handler);\n  });\n}\n\nfunction constructURL(params) {\n  const {\n    baseURL,\n    query,\n    hash\n  } = params;\n  const url = new URL(baseURL);\n\n  if (query) {\n    Object.keys(query).forEach(key => {\n      url.searchParams.append(key, query[key]);\n    });\n  }\n\n  if (hash) {\n    const h = new URL(constructURL({\n      baseURL,\n      query: hash\n    })).searchParams.toString();\n    url.hash = h;\n  }\n\n  return url.toString();\n}\n\nfunction storageAvailable(type) {\n  let storageExists = false;\n  let storageLength = 0;\n  let storage;\n\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (error) {\n    return error && ( // everything except Firefox\n    error.code === 22 || // Firefox\n    error.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    error.name === \"QuotaExceededErro r\" || // Firefox\n    error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0;\n  }\n}\n\nconst sessionStorageAvailable = storageAvailable(\"sessionStorage\");\nconst localStorageAvailable = storageAvailable(\"localStorage\");\n\nfunction preloadIframe(url) {\n  try {\n    if (typeof document === \"undefined\") return;\n    const openloginIframeHtml = document.createElement(\"link\");\n    openloginIframeHtml.href = url;\n    openloginIframeHtml.crossOrigin = \"anonymous\";\n    openloginIframeHtml.type = \"text/html\";\n    openloginIframeHtml.rel = \"prefetch\";\n\n    if (openloginIframeHtml.relList && openloginIframeHtml.relList.supports) {\n      if (openloginIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(openloginIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.error(error);\n  }\n}\n\nfunction getPopupFeatures() {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const w = 1200;\n  const h = 700;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\n\nconst handleStream = (handle, eventName, handler) => {\n  const handlerWrapper = chunk => {\n    handler(chunk);\n    handle.removeListener(eventName, handlerWrapper);\n  };\n\n  handle.on(eventName, handlerWrapper);\n};\n\nclass Modal {\n  constructor(modalUrl) {\n    _defineProperty(this, \"modalUrl\", void 0);\n\n    _defineProperty(this, \"iframeElem\", void 0);\n\n    _defineProperty(this, \"initialized\", false);\n\n    _defineProperty(this, \"modalZIndex\", 99999);\n\n    _defineProperty(this, \"mux\", void 0);\n\n    _defineProperty(this, \"verifierStream\", void 0);\n\n    this.modalUrl = modalUrl;\n  }\n\n  async init() {\n    await this.initIFrame(this.modalUrl);\n    this.setupStream();\n  }\n\n  setupStream() {\n    if (this.iframeElem === null) throw new Error(\"iframe is null\");\n    this.mux = setupMultiplex(new PostMessageStream({\n      name: \"modal_iframe_rpc\",\n      target: \"modal_rpc\",\n      targetWindow: this.iframeElem.contentWindow,\n      targetOrigin: new URL(this.modalUrl).origin\n    }));\n    this.verifierStream = this.mux.createStream(\"verifier\");\n  }\n\n  async initIFrame(src) {\n    await documentReady();\n    const documentIFrameElem = document.getElementById(modalDOMElementID);\n\n    if (documentIFrameElem) {\n      documentIFrameElem.remove();\n      log.info(\"already initialized, removing previous modal iframe\");\n    }\n\n    this.iframeElem = htmlToElement(\"<iframe\\n        id=\".concat(modalDOMElementID, \"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\").concat(src, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\n\n    this._hideModal();\n\n    document.body.appendChild(this.iframeElem);\n    return new Promise(resolve => {\n      this.iframeElem.onload = () => {\n        this.initialized = true;\n        resolve();\n      };\n    });\n  }\n\n  _showModal() {\n    const style = {};\n    style.display = \"block\";\n    style.position = \"fixed\";\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.top = \"0px\";\n    style.right = \"0px\";\n    style.left = \"0px\";\n    style.bottom = \"0px\";\n    style.border = \"0\";\n    style[\"z-index\"] = this.modalZIndex;\n    this.iframeElem.setAttribute(\"style\", Object.entries(style).map(_ref => {\n      let [k, v] = _ref;\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\";\"));\n  }\n\n  _hideModal() {\n    const style = {};\n    style.display = \"none\";\n    style.position = \"fixed\";\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.top = \"0px\";\n    style.right = \"0px\";\n    style.left = \"0px\";\n    style.bottom = \"0px\";\n    style.border = \"0\";\n    style[\"z-index\"] = this.modalZIndex;\n    this.iframeElem.setAttribute(\"style\", Object.entries(style).map(_ref2 => {\n      let [k, v] = _ref2;\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\";\"));\n  }\n\n  async _prompt(clientId, whiteLabel, loginConfig, cb) {\n    this._showModal();\n\n    const modalHandler = chunk => {\n      this._hideModal();\n\n      cb(chunk);\n    };\n\n    handleStream(this.verifierStream, \"data\", modalHandler);\n    this.verifierStream.write({\n      name: \"prompt\",\n      clientId,\n      whiteLabel,\n      loginConfig\n    });\n  }\n\n  async cleanup() {\n    await documentReady();\n    const documentIFrameElem = document.getElementById(modalDOMElementID);\n\n    if (documentIFrameElem) {\n      documentIFrameElem.remove();\n      this.iframeElem = null;\n    }\n\n    this.initialized = false;\n  }\n\n}\n\nclass MemoryStore {\n  constructor() {\n    _defineProperty(this, \"store\", {});\n  }\n\n  getItem(key) {\n    return this.store[key];\n  }\n\n  setItem(key, value) {\n    this.store[key] = value;\n  }\n\n}\n\nclass OpenLoginStore {\n  // eslint-disable-next-line no-use-before-define\n  constructor(storage) {\n    _defineProperty(this, \"storage\", void 0);\n\n    this.storage = storage;\n\n    try {\n      if (!storage.getItem(storeKey)) {\n        this.resetStore();\n      }\n    } catch (error) {// Storage is not available\n    }\n  }\n\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new this(localStorageAvailable ? localStorage : new MemoryStore());\n    }\n\n    return this.instance;\n  }\n\n  toJSON() {\n    return this.storage.getItem(storeKey);\n  }\n\n  resetStore() {\n    const currStore = this.getStore();\n    this.storage.setItem(storeKey, JSON.stringify({}));\n    return currStore;\n  }\n\n  getStore() {\n    return JSON.parse(this.storage.getItem(storeKey));\n  }\n\n  get(key) {\n    const store = JSON.parse(this.storage.getItem(storeKey));\n    return store[key];\n  }\n\n  set(key, value) {\n    const store = JSON.parse(this.storage.getItem(storeKey));\n    store[key] = value;\n    this.storage.setItem(storeKey, JSON.stringify(store));\n  }\n\n}\n\n_defineProperty(OpenLoginStore, \"instance\", void 0);\n\nclass Provider extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"iframeElem\", null);\n\n    _defineProperty(this, \"rpcStream\", void 0);\n\n    _defineProperty(this, \"iframeUrl\", void 0);\n\n    _defineProperty(this, \"rpcEngine\", void 0);\n\n    _defineProperty(this, \"initialized\", void 0);\n\n    _defineProperty(this, \"mux\", void 0);\n  }\n\n  init(_ref) {\n    let {\n      iframeElem,\n      iframeUrl\n    } = _ref;\n    this.iframeElem = iframeElem;\n    this.iframeUrl = iframeUrl;\n    this.setupStream();\n    this.initialized = true;\n  }\n\n  setupStream() {\n    if (this.iframeElem === null) throw new Error(\"iframe is null\");\n    this.rpcStream = new PostMessageStream({\n      name: \"embed_rpc\",\n      target: \"iframe_rpc\",\n      targetWindow: this.iframeElem.contentWindow,\n      targetOrigin: new URL(this.iframeUrl).origin\n    });\n    this.mux = setupMultiplex(this.rpcStream);\n    const JRPCConnection = createStreamMiddleware();\n    pump(JRPCConnection.stream, this.mux.createStream(\"jrpc\"), JRPCConnection.stream, error => {\n      log.error(\"JRPC connection broken\", error);\n    });\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(JRPCConnection.middleware);\n    this.rpcEngine = rpcEngine;\n  }\n\n  cleanup() {\n    this.iframeElem = null;\n    this.initialized = false;\n  }\n\n  _rpcRequest(payload, callback) {\n    if (!payload.jsonrpc) {\n      payload.jsonrpc = \"2.0\";\n    }\n\n    if (!payload.id) {\n      payload.id = randomId();\n    }\n\n    this.rpcEngine.handle(payload, callback);\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\npreloadIframe(\"https://app.openlogin.com/sdk-modal\");\n\nclass OpenLogin {\n  constructor(options) {\n    var _options$no3PC, _options$_startUrl, _options$_popupUrl, _options$redirectUrl, _options$uxMode, _options$replaceUrlOn, _options$originData, _options$whiteLabel, _options$loginConfig;\n\n    _defineProperty(this, \"provider\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"modal\", void 0);\n\n    this.provider = new Proxy(new Provider(), {\n      deleteProperty: () => true // work around for web3\n\n    });\n\n    if (!options._iframeUrl) {\n      if (options.network === OPENLOGIN_NETWORK.MAINNET) {\n        options._iframeUrl = \"https://app.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.CYAN) {\n        options._iframeUrl = \"https://cyan.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.TESTNET) {\n        options._iframeUrl = \"https://beta.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.DEVELOPMENT) {\n        options._iframeUrl = \"http://localhost:3000\";\n      }\n    }\n\n    if (!options._iframeUrl) {\n      throw new Error(\"unspecified network and iframeUrl\");\n    }\n\n    this.modal = new Modal(\"\".concat(options._iframeUrl, \"/sdk-modal\"));\n    this.initState(_objectSpread(_objectSpread({}, options), {}, {\n      no3PC: (_options$no3PC = options.no3PC) !== null && _options$no3PC !== void 0 ? _options$no3PC : false,\n      _iframeUrl: options._iframeUrl,\n      _startUrl: (_options$_startUrl = options._startUrl) !== null && _options$_startUrl !== void 0 ? _options$_startUrl : \"\".concat(options._iframeUrl, \"/start\"),\n      _popupUrl: (_options$_popupUrl = options._popupUrl) !== null && _options$_popupUrl !== void 0 ? _options$_popupUrl : \"\".concat(options._iframeUrl, \"/popup-window\"),\n      redirectUrl: (_options$redirectUrl = options.redirectUrl) !== null && _options$redirectUrl !== void 0 ? _options$redirectUrl : \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(window.location.pathname),\n      uxMode: (_options$uxMode = options.uxMode) !== null && _options$uxMode !== void 0 ? _options$uxMode : UX_MODE.REDIRECT,\n      replaceUrlOnRedirect: (_options$replaceUrlOn = options.replaceUrlOnRedirect) !== null && _options$replaceUrlOn !== void 0 ? _options$replaceUrlOn : true,\n      originData: (_options$originData = options.originData) !== null && _options$originData !== void 0 ? _options$originData : {\n        [window.location.origin]: \"\"\n      },\n      whiteLabel: (_options$whiteLabel = options.whiteLabel) !== null && _options$whiteLabel !== void 0 ? _options$whiteLabel : {},\n      loginConfig: (_options$loginConfig = options.loginConfig) !== null && _options$loginConfig !== void 0 ? _options$loginConfig : {}\n    }));\n  }\n\n  get privKey() {\n    return this.state.privKey ? this.state.privKey.padStart(64, \"0\") : \"\";\n  }\n\n  initState(options) {\n    this.state = {\n      uxMode: options.uxMode,\n      network: options.network,\n      store: OpenLoginStore.getInstance(),\n      iframeUrl: options._iframeUrl,\n      startUrl: options._startUrl,\n      popupUrl: options._popupUrl,\n      clientId: options.clientId,\n      redirectUrl: options.redirectUrl,\n      replaceUrlOnRedirect: options.replaceUrlOnRedirect,\n      originData: options.originData,\n      loginConfig: options.loginConfig,\n      support3PC: !options.no3PC,\n      whiteLabel: options.whiteLabel\n    };\n  }\n\n  async init() {\n    if (this.state.support3PC) {\n      await Promise.all([this.modal.init(), this.updateOriginData()]);\n      this.provider.init({\n        iframeElem: this.modal.iframeElem,\n        iframeUrl: this.state.iframeUrl\n      });\n\n      this._syncState(getHashQueryParams(this.state.replaceUrlOnRedirect));\n\n      const res = await this._check3PCSupport();\n      this.state.support3PC = !!res.support3PC;\n\n      if (this.state.support3PC) {\n        this._syncState(await this._getData());\n      }\n    } else {\n      await this.updateOriginData();\n\n      this._syncState(getHashQueryParams(this.state.replaceUrlOnRedirect));\n    }\n  }\n\n  async updateOriginData() {\n    const filteredOriginData = JSON.parse(JSON.stringify(this.state.originData));\n    Object.keys(filteredOriginData).forEach(key => {\n      if (filteredOriginData[key] === \"\") delete filteredOriginData[key];\n    });\n    const [whitelist, whiteLabel] = await Promise.all([this.getWhitelist(), this.getWhiteLabel()]);\n\n    this._syncState({\n      originData: _objectSpread(_objectSpread({}, whitelist), filteredOriginData),\n      whiteLabel: _objectSpread(_objectSpread({}, whiteLabel), this.state.whiteLabel)\n    });\n  }\n\n  async getWhitelist() {\n    try {\n      const {\n        clientId\n      } = this.state;\n\n      if (!clientId) {\n        throw new Error(\"unspecified clientId\");\n      }\n\n      const url = new URL(\"https://api.developer.tor.us/whitelist\");\n      url.searchParams.append(\"project_id\", this.state.clientId);\n      const res = await get(url.href);\n      return res.signed_urls;\n    } catch (_) {\n      // fail silently\n      return {};\n    }\n  }\n\n  async getWhiteLabel() {\n    try {\n      const {\n        clientId\n      } = this.state;\n\n      if (!clientId) {\n        throw new Error(\"unspecified clientId\");\n      }\n\n      const url = new URL(\"https://api.developer.tor.us/whitelabel\");\n      url.searchParams.append(\"project_id\", this.state.clientId);\n      const res = await get(url.href);\n      return res.whiteLabel;\n    } catch (_) {\n      // fail silently\n      return {};\n    }\n  }\n\n  async _fastLogin(params) {\n    const defaultParams = {\n      redirectUrl: this.state.redirectUrl\n    };\n\n    const loginParams = _objectSpread(_objectSpread({}, defaultParams), params);\n\n    const res = await this.request({\n      params: [_objectSpread(_objectSpread({}, loginParams), {}, {\n        fastLogin: true\n      })],\n      method: OPENLOGIN_METHOD.LOGIN,\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      allowedInteractions: [ALLOWED_INTERACTIONS.POPUP, ALLOWED_INTERACTIONS.REDIRECT]\n    });\n    this.state.privKey = res.privKey;\n    return res;\n  }\n\n  async login(params) {\n    if (params !== null && params !== void 0 && params.loginProvider) {\n      return this._selectedLogin(params);\n    }\n\n    return this._modal(params);\n  }\n\n  async _selectedLogin(params) {\n    const defaultParams = {\n      redirectUrl: this.state.redirectUrl\n    };\n\n    const loginParams = _objectSpread(_objectSpread({\n      loginProvider: params.loginProvider\n    }, defaultParams), params); // fast login flow\n    // if (this.state.store.get(\"touchIDPreference\") === \"enabled\" && !loginParams.extraLoginOptions?.login_hint) {\n    //   return this._fastLogin(loginParams);\n    // }\n\n\n    const res = await this.request({\n      method: OPENLOGIN_METHOD.LOGIN,\n      allowedInteractions: [UX_MODE.REDIRECT, UX_MODE.POPUP],\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      params: [loginParams]\n    });\n    this.state.privKey = res.privKey;\n\n    if (res.store) {\n      this._syncState(res);\n    } else if (this.state.privKey && this.state.support3PC) {\n      this._syncState(await this._getData());\n    }\n\n    return {\n      privKey: this.privKey\n    };\n  }\n\n  async logout() {\n    let logoutParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const params = {}; // defaults\n\n    params.redirectUrl = this.state.redirectUrl;\n    params._clientId = this.state.clientId;\n\n    if (logoutParams.clientId) {\n      params._clientId = logoutParams.clientId;\n    }\n\n    if (logoutParams.fastLogin !== undefined) {\n      params.fastLogin = logoutParams.fastLogin;\n    }\n\n    if (logoutParams.redirectUrl !== undefined) {\n      params.redirectUrl = logoutParams.redirectUrl;\n    }\n\n    const res = await this.request({\n      method: OPENLOGIN_METHOD.LOGOUT,\n      params: [params],\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC, ALLOWED_INTERACTIONS.POPUP, ALLOWED_INTERACTIONS.REDIRECT]\n    });\n    this.state.privKey = \"\"; // if (!params.fastLogin) this.state.store.set(\"touchIDPreference\", \"disabled\");\n\n    return res;\n  }\n\n  async request(args) {\n    var _params$0$redirectUrl;\n\n    const pid = randomId();\n    let {\n      params\n    } = args; // Note: _origin is added later in postMessageStream for jrpc requests\n    // do not add it here since its used for checking postMessage constraints\n\n    const session = {};\n    if (params.length !== 1) throw new Error(\"request params array should have only one element\");\n    const {\n      startUrl,\n      popupUrl,\n      method,\n      allowedInteractions\n    } = args;\n    if (allowedInteractions.length === 0) throw new Error(\"no allowed interactions\");\n\n    if (this.state.clientId) {\n      session._clientId = this.state.clientId;\n    }\n\n    if (this.privKey) {\n      const userData = {\n        clientId: session._clientId,\n        timestamp: Date.now().toString()\n      };\n      const sig = await sign(Buffer.from(this.privKey, \"hex\"), Buffer.from(keccak(\"keccak256\").update(JSON.stringify(userData)).digest(\"hex\"), \"hex\"));\n      session._user = getPublic(Buffer.from(this.privKey, \"hex\")).toString(\"hex\");\n      session._userSig = base64url.encode(sig);\n      session._userData = userData;\n    }\n\n    session._originData = this.state.originData;\n    session._whiteLabelData = this.state.whiteLabel;\n    session._loginConfig = this.state.loginConfig; // add in session data (allow overrides)\n\n    params = [_objectSpread(_objectSpread({}, session), params[0])]; // use JRPC where possible\n\n    if (this.state.support3PC && allowedInteractions.includes(ALLOWED_INTERACTIONS.JRPC)) {\n      return this._jrpcRequest({\n        method,\n        params\n      });\n    } // set origin\n\n\n    params[0]._origin = new URL((_params$0$redirectUrl = params[0].redirectUrl) !== null && _params$0$redirectUrl !== void 0 ? _params$0$redirectUrl : this.state.redirectUrl).origin; // preset params\n\n    if (this.state.support3PC) {\n      // set params first if 3PC supported\n      await this._setPIDData(pid, params); // eslint-disable-next-line require-atomic-updates\n\n      params = [{}];\n    }\n\n    if (!startUrl || !popupUrl) {\n      throw new Error(\"no url for redirect / popup flow\");\n    } // method and pid are always in URL hash params\n    // convert params from JSON to base64\n\n\n    if (this.state.uxMode === UX_MODE.REDIRECT) {\n      // if redirects preferred, check for redirect flows first, then check for popup flow\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n        // give time for synchronous methods to complete before redirect\n        setTimeout(() => {\n          window.location.href = constructURL({\n            baseURL: startUrl,\n            hash: {\n              b64Params: jsonToBase64(params[0]),\n              _pid: pid,\n              _method: method\n            }\n          });\n        }, 50);\n        return {};\n      }\n\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n        const u = new URL(constructURL({\n          baseURL: popupUrl,\n          hash: {\n            b64Params: jsonToBase64(params[0]),\n            _pid: pid,\n            _method: method\n          }\n        }));\n        const windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n        return awaitReq(pid, windowRef);\n      }\n    } else {\n      // if popups preferred, check for popup flows first, then check for redirect flow\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n        const u = new URL(constructURL({\n          baseURL: popupUrl,\n          hash: {\n            b64Params: jsonToBase64(params[0]),\n            _pid: pid,\n            _method: method\n          }\n        }));\n        const windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n        return awaitReq(pid, windowRef);\n      }\n\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n        // give time for synchronous methods to complete before redirect\n        setTimeout(() => {\n          window.location.href = constructURL({\n            baseURL: startUrl,\n            hash: {\n              b64Params: jsonToBase64(params[0]),\n              _pid: pid,\n              _method: method\n            }\n          });\n        }, 50);\n        return null;\n      }\n    }\n\n    throw new Error(\"no matching allowed interactions\");\n  }\n\n  async _jrpcRequest(args) {\n    // await this.initialized;\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw new Error(\"invalid request args\");\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw new Error(\"invalid request method\");\n    }\n\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error(\"invalid request params\");\n    }\n\n    if (params.length === 0) {\n      params.push({});\n    }\n\n    return new Promise((resolve, reject) => {\n      this.provider._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n\n  async _check3PCSupport() {\n    return this._jrpcRequest({\n      method: OPENLOGIN_METHOD.CHECK_3PC_SUPPORT,\n      params: [{\n        _originData: this.state.originData\n      }]\n    });\n  }\n\n  async _setPIDData(pid, data) {\n    await this.request({\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n      method: OPENLOGIN_METHOD.SET_PID_DATA,\n      params: [{\n        pid,\n        data: data[0]\n      }]\n    });\n  }\n\n  async _getData() {\n    return this.request({\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n      method: OPENLOGIN_METHOD.GET_DATA,\n      params: [{}]\n    });\n  }\n\n  _syncState(newState) {\n    if (newState.store) {\n      if (typeof newState.store !== \"object\") {\n        throw new Error(\"expected store to be an object\");\n      }\n\n      Object.keys(newState.store).forEach(key => {\n        // if privKey is available then user is not logged out, but in popup mode store info is not available.\n        // so we don't want to overwrite the local store if privKey is available\n        // and if latest iframe store data is not available\n        if (newState.privKey) {\n          if (newState.store[key]) {\n            this.state.store.set(key, newState.store[key]);\n          }\n        } else {\n          this.state.store.set(key, newState.store[key]);\n        }\n      });\n    }\n\n    const {\n      store\n    } = this.state;\n    this.state = _objectSpread(_objectSpread(_objectSpread({}, this.state), newState), {}, {\n      store\n    });\n  }\n\n  async _modal(params) {\n    return new Promise((resolve, reject) => {\n      this.modal._prompt(this.state.clientId, this.state.whiteLabel, this.state.loginConfig, async chunk => {\n        if (chunk.cancel) {\n          reject(new Error(\"user canceled login\"));\n        } else {\n          try {\n            const selectedLoginResponse = await this._selectedLogin(merge(params, chunk));\n            resolve(selectedLoginResponse);\n          } catch (error) {\n            reject(error);\n          }\n        }\n      });\n    });\n  }\n\n  async _cleanup() {\n    await this.modal.cleanup();\n    this.provider.cleanup();\n  }\n\n  async encrypt(message, privateKey) {\n    let privKey = privateKey;\n\n    if (!privKey) {\n      privKey = this.privKey;\n    } // validations\n\n\n    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n      if (privKey === \"\" || privKey === undefined) {\n        throw new Error(\"private key cannot be empty\");\n      } else {\n        throw new Error(\"invalid private key in encrypt\");\n      }\n    }\n\n    return encrypt(getPublic(Buffer.from(privKey, \"hex\")), message);\n  }\n\n  async decrypt(ciphertext, privateKey) {\n    let privKey = privateKey;\n\n    if (!privKey) {\n      privKey = this.privKey;\n    } // validations\n\n\n    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n      if (privKey === \"\" || privKey === undefined) {\n        throw new Error(\"private key cannot be empty\");\n      } else {\n        throw new Error(\"invalid private key in decrypt\");\n      }\n    }\n\n    return decrypt(Buffer.from(privKey, \"hex\"), ciphertext);\n  }\n\n  async getUserInfo() {\n    if (this.privKey) {\n      const storeData = this.state.store.getStore();\n      const userInfo = {\n        email: storeData.email || \"\",\n        name: storeData.name || \"\",\n        profileImage: storeData.profileImage || \"\",\n        aggregateVerifier: storeData.aggregateVerifier || \"\",\n        verifier: storeData.verifier || \"\",\n        verifierId: storeData.verifierId || \"\",\n        typeOfLogin: storeData.typeOfLogin || \"\",\n        dappShare: storeData.dappShare || \"\"\n      };\n      return userInfo;\n    }\n\n    throw new Error(\"user should be logged in to fetch userInfo\");\n  }\n\n  async getEncodedLoginUrl(loginParams) {\n    const {\n      redirectUrl\n    } = loginParams;\n    const {\n      clientId\n    } = this.state;\n\n    if (!this.state.originData[origin]) {\n      await this.updateOriginData();\n    }\n\n    const dataObject = _objectSpread({\n      _clientId: clientId,\n      _origin: new URL(redirectUrl).origin,\n      _originData: this.state.originData,\n      redirectUrl\n    }, loginParams);\n\n    const b64Params = jsonToBase64(dataObject);\n    const hashParams = {\n      b64Params,\n      _method: \"openlogin_login\"\n    };\n    return constructURL({\n      baseURL: \"\".concat(this.state.iframeUrl, \"/start\"),\n      hash: hashParams\n    });\n  }\n\n}\n\nexport { ALLOWED_INTERACTIONS, LOGIN_PROVIDER, MFA_LEVELS, OPENLOGIN_METHOD, OPENLOGIN_NETWORK, OpenLoginStore, Provider, UX_MODE, awaitReq, constructURL, OpenLogin as default, documentReady, getHashQueryParams, getPopupFeatures, htmlToElement, localStorageAvailable, log as loglevel, modalDOMElementID, preloadIframe, sessionStorageAvailable, storageAvailable, storeKey, whitelistUrl };","map":{"version":3,"sources":["../src/constants.ts","../src/loglevel.ts","../src/utils.ts","../src/Modal.ts","../src/MemoryStore.ts","../src/OpenLoginStore.ts","../src/Provider.ts","../src/OpenLogin.ts"],"names":["modalDOMElementID","storeKey","UX_MODE","POPUP","REDIRECT","OPENLOGIN_METHOD","LOGIN","LOGOUT","CHECK_3PC_SUPPORT","SET_PID_DATA","GET_DATA","ALLOWED_INTERACTIONS","JRPC","OPENLOGIN_NETWORK","MAINNET","TESTNET","CYAN","DEVELOPMENT","LOGIN_PROVIDER","GOOGLE","FACEBOOK","REDDIT","DISCORD","TWITCH","APPLE","LINE","GITHUB","KAKAO","LINKEDIN","TWITTER","WEIBO","WECHAT","EMAIL_PASSWORDLESS","WEBAUTHN","JWT","MFA_LEVELS","DEFAULT","OPTIONAL","MANDATORY","loglevel","resolve","document","htmlToElement","html","template","window","trimmedHtml","appKeyBuf","Buffer","appKey","base64url","getPublic","sig","sign","keccak","getHashQueryParams","replaceUrl","result","url","key","queryResult","queryParams","JSON","safeatob","Object","log","hash","hashUrl","hashResult","hashParams","cleanUrl","awaitReq","id","windowRef","reject","closedByHandler","closedMonitor","setInterval","clearInterval","handler","ev","pid","constructURL","params","query","h","storageAvailable","type","storageExists","storageLength","storage","x","error","sessionStorageAvailable","localStorageAvailable","preloadIframe","openloginIframeHtml","getPopupFeatures","dualScreenLeft","dualScreenTop","w","width","height","systemZoom","left","Math","top","features","handleStream","handlerWrapper","chunk","handle","Modal","constructor","modalUrl","init","setupStream","setupMultiplex","name","target","targetWindow","targetOrigin","origin","initIFrame","documentReady","documentIFrameElem","_showModal","style","_hideModal","_prompt","modalHandler","cb","loginConfig","cleanup","MemoryStore","getItem","setItem","OpenLoginStore","getInstance","toJSON","resetStore","currStore","getStore","get","store","set","Provider","SafeEventEmitter","iframeUrl","JRPCConnection","createStreamMiddleware","pump","rpcEngine","createIdRemapMiddleware","_rpcRequest","payload","randomId","options","deleteProperty","no3PC","_iframeUrl","_startUrl","_popupUrl","redirectUrl","uxMode","replaceUrlOnRedirect","originData","whiteLabel","privKey","initState","network","startUrl","popupUrl","clientId","support3PC","Promise","iframeElem","res","updateOriginData","filteredOriginData","getWhitelist","getWhiteLabel","_fastLogin","defaultParams","loginParams","fastLogin","method","allowedInteractions","login","_selectedLogin","loginProvider","logout","logoutParams","request","session","userData","timestamp","Date","setTimeout","baseURL","b64Params","jsonToBase64","_pid","_method","u","_jrpcRequest","Array","getRpcPromiseCallback","_check3PCSupport","_originData","_setPIDData","data","_getData","_syncState","newState","_modal","selectedLoginResponse","merge","_cleanup","encrypt","decrypt","getUserInfo","storeData","userInfo","email","profileImage","aggregateVerifier","verifier","verifierId","typeOfLogin","dappShare","getEncodedLoginUrl","dataObject","_clientId","_origin"],"mappings":"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","sourcesContent":["import loglevel from 'loglevel';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { getPublic, sign, encrypt, decrypt } from '@toruslabs/eccrypto';\nimport { get } from '@toruslabs/http-helpers';\nimport { setupMultiplex, PostMessageStream, SafeEventEmitter, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, getRpcPromiseCallback } from '@toruslabs/openlogin-jrpc';\nimport { base64url, keccak, safeatob, randomId, jsonToBase64 } from '@toruslabs/openlogin-utils';\nimport merge from 'lodash.merge';\nimport pump from 'pump';\n\nconst modalDOMElementID = \"openlogin-modal\";\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_METHOD = {\n  LOGIN: \"openlogin_login\",\n  LOGOUT: \"openlogin_logout\",\n  CHECK_3PC_SUPPORT: \"openlogin_check_3PC_support\",\n  SET_PID_DATA: \"openlogin_set_pid_data\",\n  GET_DATA: \"openlogin_get_data\"\n};\nconst ALLOWED_INTERACTIONS = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\",\n  JRPC: \"jrpc\"\n};\nconst OPENLOGIN_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  DEVELOPMENT: \"development\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n  WEBAUTHN: \"webauthn\",\n  JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n  DEFAULT: \"default\",\n  OPTIONAL: \"optional\",\n  MANDATORY: \"mandatory\"\n};\n\nloglevel.setLevel(\"error\");\nvar log = loglevel.getLogger(\"openlogin\");\n\nasync function documentReady() {\n  return new Promise(resolve => {\n    if (document.readyState !== \"loading\") {\n      resolve();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        resolve();\n      });\n    }\n  });\n}\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\nasync function whitelistUrl(clientId, appKey, origin) {\n  const appKeyBuf = Buffer.from(appKey.padStart(64, \"0\"), \"hex\");\n  if (base64url.encode(getPublic(appKeyBuf)) !== clientId) throw new Error(\"appKey mismatch\");\n  const sig = await sign(appKeyBuf, Buffer.from(keccak(\"keccak256\").update(origin).digest(\"hex\"), \"hex\"));\n  return base64url.encode(sig);\n}\nfunction getHashQueryParams() {\n  let replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const result = {};\n  const url = new URL(window.location.href);\n  url.searchParams.forEach((value, key) => {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  const queryResult = url.searchParams.get(\"result\");\n\n  if (queryResult) {\n    try {\n      const queryParams = JSON.parse(safeatob(queryResult));\n      Object.keys(queryParams).forEach(key => {\n        result[key] = queryParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  const hash = url.hash.substring(1);\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash));\n  hashUrl.searchParams.forEach((value, key) => {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  const hashResult = hashUrl.searchParams.get(\"result\");\n\n  if (hashResult) {\n    try {\n      const hashParams = JSON.parse(safeatob(hashResult));\n      Object.keys(hashParams).forEach(key => {\n        result[key] = hashParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  if (replaceUrl) {\n    const cleanUrl = window.location.origin + window.location.pathname;\n    window.history.replaceState(null, \"\", cleanUrl);\n  }\n\n  return result;\n}\nfunction awaitReq(id, windowRef) {\n  return new Promise((resolve, reject) => {\n    if (!windowRef) reject(new Error(\"Unable to open window\"));\n    let closedByHandler = false;\n    const closedMonitor = setInterval(() => {\n      if (!closedByHandler && windowRef.closed) {\n        clearInterval(closedMonitor);\n        reject(new Error(\"user closed popup\"));\n      }\n    }, 500);\n\n    const handler = ev => {\n      const {\n        pid\n      } = ev.data;\n      if (id !== pid) return;\n      window.removeEventListener(\"message\", handler);\n      closedByHandler = true;\n      clearInterval(closedMonitor);\n      windowRef.close();\n\n      if (ev.data.data && ev.data.data.error) {\n        reject(new Error(ev.data.data.error));\n      } else {\n        resolve(ev.data.data);\n      }\n    };\n\n    window.addEventListener(\"message\", handler);\n  });\n}\nfunction constructURL(params) {\n  const {\n    baseURL,\n    query,\n    hash\n  } = params;\n  const url = new URL(baseURL);\n\n  if (query) {\n    Object.keys(query).forEach(key => {\n      url.searchParams.append(key, query[key]);\n    });\n  }\n\n  if (hash) {\n    const h = new URL(constructURL({\n      baseURL,\n      query: hash\n    })).searchParams.toString();\n    url.hash = h;\n  }\n\n  return url.toString();\n}\nfunction storageAvailable(type) {\n  let storageExists = false;\n  let storageLength = 0;\n  let storage;\n\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (error) {\n    return error && ( // everything except Firefox\n    error.code === 22 || // Firefox\n    error.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    error.name === \"QuotaExceededErro r\" || // Firefox\n    error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0;\n  }\n}\nconst sessionStorageAvailable = storageAvailable(\"sessionStorage\");\nconst localStorageAvailable = storageAvailable(\"localStorage\");\nfunction preloadIframe(url) {\n  try {\n    if (typeof document === \"undefined\") return;\n    const openloginIframeHtml = document.createElement(\"link\");\n    openloginIframeHtml.href = url;\n    openloginIframeHtml.crossOrigin = \"anonymous\";\n    openloginIframeHtml.type = \"text/html\";\n    openloginIframeHtml.rel = \"prefetch\";\n\n    if (openloginIframeHtml.relList && openloginIframeHtml.relList.supports) {\n      if (openloginIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(openloginIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.error(error);\n  }\n}\nfunction getPopupFeatures() {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const w = 1200;\n  const h = 700;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\n\nconst handleStream = (handle, eventName, handler) => {\n  const handlerWrapper = chunk => {\n    handler(chunk);\n    handle.removeListener(eventName, handlerWrapper);\n  };\n\n  handle.on(eventName, handlerWrapper);\n};\nclass Modal {\n  constructor(modalUrl) {\n    _defineProperty(this, \"modalUrl\", void 0);\n\n    _defineProperty(this, \"iframeElem\", void 0);\n\n    _defineProperty(this, \"initialized\", false);\n\n    _defineProperty(this, \"modalZIndex\", 99999);\n\n    _defineProperty(this, \"mux\", void 0);\n\n    _defineProperty(this, \"verifierStream\", void 0);\n\n    this.modalUrl = modalUrl;\n  }\n\n  async init() {\n    await this.initIFrame(this.modalUrl);\n    this.setupStream();\n  }\n\n  setupStream() {\n    if (this.iframeElem === null) throw new Error(\"iframe is null\");\n    this.mux = setupMultiplex(new PostMessageStream({\n      name: \"modal_iframe_rpc\",\n      target: \"modal_rpc\",\n      targetWindow: this.iframeElem.contentWindow,\n      targetOrigin: new URL(this.modalUrl).origin\n    }));\n    this.verifierStream = this.mux.createStream(\"verifier\");\n  }\n\n  async initIFrame(src) {\n    await documentReady();\n    const documentIFrameElem = document.getElementById(modalDOMElementID);\n\n    if (documentIFrameElem) {\n      documentIFrameElem.remove();\n      log.info(\"already initialized, removing previous modal iframe\");\n    }\n\n    this.iframeElem = htmlToElement(\"<iframe\\n        id=\".concat(modalDOMElementID, \"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\").concat(src, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\n\n    this._hideModal();\n\n    document.body.appendChild(this.iframeElem);\n    return new Promise(resolve => {\n      this.iframeElem.onload = () => {\n        this.initialized = true;\n        resolve();\n      };\n    });\n  }\n\n  _showModal() {\n    const style = {};\n    style.display = \"block\";\n    style.position = \"fixed\";\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.top = \"0px\";\n    style.right = \"0px\";\n    style.left = \"0px\";\n    style.bottom = \"0px\";\n    style.border = \"0\";\n    style[\"z-index\"] = this.modalZIndex;\n    this.iframeElem.setAttribute(\"style\", Object.entries(style).map(_ref => {\n      let [k, v] = _ref;\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\";\"));\n  }\n\n  _hideModal() {\n    const style = {};\n    style.display = \"none\";\n    style.position = \"fixed\";\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.top = \"0px\";\n    style.right = \"0px\";\n    style.left = \"0px\";\n    style.bottom = \"0px\";\n    style.border = \"0\";\n    style[\"z-index\"] = this.modalZIndex;\n    this.iframeElem.setAttribute(\"style\", Object.entries(style).map(_ref2 => {\n      let [k, v] = _ref2;\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\";\"));\n  }\n\n  async _prompt(clientId, whiteLabel, loginConfig, cb) {\n    this._showModal();\n\n    const modalHandler = chunk => {\n      this._hideModal();\n\n      cb(chunk);\n    };\n\n    handleStream(this.verifierStream, \"data\", modalHandler);\n    this.verifierStream.write({\n      name: \"prompt\",\n      clientId,\n      whiteLabel,\n      loginConfig\n    });\n  }\n\n  async cleanup() {\n    await documentReady();\n    const documentIFrameElem = document.getElementById(modalDOMElementID);\n\n    if (documentIFrameElem) {\n      documentIFrameElem.remove();\n      this.iframeElem = null;\n    }\n\n    this.initialized = false;\n  }\n\n}\n\nclass MemoryStore {\n  constructor() {\n    _defineProperty(this, \"store\", {});\n  }\n\n  getItem(key) {\n    return this.store[key];\n  }\n\n  setItem(key, value) {\n    this.store[key] = value;\n  }\n\n}\n\nclass OpenLoginStore {\n  // eslint-disable-next-line no-use-before-define\n  constructor(storage) {\n    _defineProperty(this, \"storage\", void 0);\n\n    this.storage = storage;\n\n    try {\n      if (!storage.getItem(storeKey)) {\n        this.resetStore();\n      }\n    } catch (error) {// Storage is not available\n    }\n  }\n\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new this(localStorageAvailable ? localStorage : new MemoryStore());\n    }\n\n    return this.instance;\n  }\n\n  toJSON() {\n    return this.storage.getItem(storeKey);\n  }\n\n  resetStore() {\n    const currStore = this.getStore();\n    this.storage.setItem(storeKey, JSON.stringify({}));\n    return currStore;\n  }\n\n  getStore() {\n    return JSON.parse(this.storage.getItem(storeKey));\n  }\n\n  get(key) {\n    const store = JSON.parse(this.storage.getItem(storeKey));\n    return store[key];\n  }\n\n  set(key, value) {\n    const store = JSON.parse(this.storage.getItem(storeKey));\n    store[key] = value;\n    this.storage.setItem(storeKey, JSON.stringify(store));\n  }\n\n}\n\n_defineProperty(OpenLoginStore, \"instance\", void 0);\n\nclass Provider extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"iframeElem\", null);\n\n    _defineProperty(this, \"rpcStream\", void 0);\n\n    _defineProperty(this, \"iframeUrl\", void 0);\n\n    _defineProperty(this, \"rpcEngine\", void 0);\n\n    _defineProperty(this, \"initialized\", void 0);\n\n    _defineProperty(this, \"mux\", void 0);\n  }\n\n  init(_ref) {\n    let {\n      iframeElem,\n      iframeUrl\n    } = _ref;\n    this.iframeElem = iframeElem;\n    this.iframeUrl = iframeUrl;\n    this.setupStream();\n    this.initialized = true;\n  }\n\n  setupStream() {\n    if (this.iframeElem === null) throw new Error(\"iframe is null\");\n    this.rpcStream = new PostMessageStream({\n      name: \"embed_rpc\",\n      target: \"iframe_rpc\",\n      targetWindow: this.iframeElem.contentWindow,\n      targetOrigin: new URL(this.iframeUrl).origin\n    });\n    this.mux = setupMultiplex(this.rpcStream);\n    const JRPCConnection = createStreamMiddleware();\n    pump(JRPCConnection.stream, this.mux.createStream(\"jrpc\"), JRPCConnection.stream, error => {\n      log.error(\"JRPC connection broken\", error);\n    });\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(JRPCConnection.middleware);\n    this.rpcEngine = rpcEngine;\n  }\n\n  cleanup() {\n    this.iframeElem = null;\n    this.initialized = false;\n  }\n\n  _rpcRequest(payload, callback) {\n    if (!payload.jsonrpc) {\n      payload.jsonrpc = \"2.0\";\n    }\n\n    if (!payload.id) {\n      payload.id = randomId();\n    }\n\n    this.rpcEngine.handle(payload, callback);\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\npreloadIframe(\"https://app.openlogin.com/sdk-modal\");\n\nclass OpenLogin {\n  constructor(options) {\n    var _options$no3PC, _options$_startUrl, _options$_popupUrl, _options$redirectUrl, _options$uxMode, _options$replaceUrlOn, _options$originData, _options$whiteLabel, _options$loginConfig;\n\n    _defineProperty(this, \"provider\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"modal\", void 0);\n\n    this.provider = new Proxy(new Provider(), {\n      deleteProperty: () => true // work around for web3\n\n    });\n\n    if (!options._iframeUrl) {\n      if (options.network === OPENLOGIN_NETWORK.MAINNET) {\n        options._iframeUrl = \"https://app.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.CYAN) {\n        options._iframeUrl = \"https://cyan.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.TESTNET) {\n        options._iframeUrl = \"https://beta.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.DEVELOPMENT) {\n        options._iframeUrl = \"http://localhost:3000\";\n      }\n    }\n\n    if (!options._iframeUrl) {\n      throw new Error(\"unspecified network and iframeUrl\");\n    }\n\n    this.modal = new Modal(\"\".concat(options._iframeUrl, \"/sdk-modal\"));\n    this.initState(_objectSpread(_objectSpread({}, options), {}, {\n      no3PC: (_options$no3PC = options.no3PC) !== null && _options$no3PC !== void 0 ? _options$no3PC : false,\n      _iframeUrl: options._iframeUrl,\n      _startUrl: (_options$_startUrl = options._startUrl) !== null && _options$_startUrl !== void 0 ? _options$_startUrl : \"\".concat(options._iframeUrl, \"/start\"),\n      _popupUrl: (_options$_popupUrl = options._popupUrl) !== null && _options$_popupUrl !== void 0 ? _options$_popupUrl : \"\".concat(options._iframeUrl, \"/popup-window\"),\n      redirectUrl: (_options$redirectUrl = options.redirectUrl) !== null && _options$redirectUrl !== void 0 ? _options$redirectUrl : \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(window.location.pathname),\n      uxMode: (_options$uxMode = options.uxMode) !== null && _options$uxMode !== void 0 ? _options$uxMode : UX_MODE.REDIRECT,\n      replaceUrlOnRedirect: (_options$replaceUrlOn = options.replaceUrlOnRedirect) !== null && _options$replaceUrlOn !== void 0 ? _options$replaceUrlOn : true,\n      originData: (_options$originData = options.originData) !== null && _options$originData !== void 0 ? _options$originData : {\n        [window.location.origin]: \"\"\n      },\n      whiteLabel: (_options$whiteLabel = options.whiteLabel) !== null && _options$whiteLabel !== void 0 ? _options$whiteLabel : {},\n      loginConfig: (_options$loginConfig = options.loginConfig) !== null && _options$loginConfig !== void 0 ? _options$loginConfig : {}\n    }));\n  }\n\n  get privKey() {\n    return this.state.privKey ? this.state.privKey.padStart(64, \"0\") : \"\";\n  }\n\n  initState(options) {\n    this.state = {\n      uxMode: options.uxMode,\n      network: options.network,\n      store: OpenLoginStore.getInstance(),\n      iframeUrl: options._iframeUrl,\n      startUrl: options._startUrl,\n      popupUrl: options._popupUrl,\n      clientId: options.clientId,\n      redirectUrl: options.redirectUrl,\n      replaceUrlOnRedirect: options.replaceUrlOnRedirect,\n      originData: options.originData,\n      loginConfig: options.loginConfig,\n      support3PC: !options.no3PC,\n      whiteLabel: options.whiteLabel\n    };\n  }\n\n  async init() {\n    if (this.state.support3PC) {\n      await Promise.all([this.modal.init(), this.updateOriginData()]);\n      this.provider.init({\n        iframeElem: this.modal.iframeElem,\n        iframeUrl: this.state.iframeUrl\n      });\n\n      this._syncState(getHashQueryParams(this.state.replaceUrlOnRedirect));\n\n      const res = await this._check3PCSupport();\n      this.state.support3PC = !!res.support3PC;\n\n      if (this.state.support3PC) {\n        this._syncState(await this._getData());\n      }\n    } else {\n      await this.updateOriginData();\n\n      this._syncState(getHashQueryParams(this.state.replaceUrlOnRedirect));\n    }\n  }\n\n  async updateOriginData() {\n    const filteredOriginData = JSON.parse(JSON.stringify(this.state.originData));\n    Object.keys(filteredOriginData).forEach(key => {\n      if (filteredOriginData[key] === \"\") delete filteredOriginData[key];\n    });\n    const [whitelist, whiteLabel] = await Promise.all([this.getWhitelist(), this.getWhiteLabel()]);\n\n    this._syncState({\n      originData: _objectSpread(_objectSpread({}, whitelist), filteredOriginData),\n      whiteLabel: _objectSpread(_objectSpread({}, whiteLabel), this.state.whiteLabel)\n    });\n  }\n\n  async getWhitelist() {\n    try {\n      const {\n        clientId\n      } = this.state;\n\n      if (!clientId) {\n        throw new Error(\"unspecified clientId\");\n      }\n\n      const url = new URL(\"https://api.developer.tor.us/whitelist\");\n      url.searchParams.append(\"project_id\", this.state.clientId);\n      const res = await get(url.href);\n      return res.signed_urls;\n    } catch (_) {\n      // fail silently\n      return {};\n    }\n  }\n\n  async getWhiteLabel() {\n    try {\n      const {\n        clientId\n      } = this.state;\n\n      if (!clientId) {\n        throw new Error(\"unspecified clientId\");\n      }\n\n      const url = new URL(\"https://api.developer.tor.us/whitelabel\");\n      url.searchParams.append(\"project_id\", this.state.clientId);\n      const res = await get(url.href);\n      return res.whiteLabel;\n    } catch (_) {\n      // fail silently\n      return {};\n    }\n  }\n\n  async _fastLogin(params) {\n    const defaultParams = {\n      redirectUrl: this.state.redirectUrl\n    };\n\n    const loginParams = _objectSpread(_objectSpread({}, defaultParams), params);\n\n    const res = await this.request({\n      params: [_objectSpread(_objectSpread({}, loginParams), {}, {\n        fastLogin: true\n      })],\n      method: OPENLOGIN_METHOD.LOGIN,\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      allowedInteractions: [ALLOWED_INTERACTIONS.POPUP, ALLOWED_INTERACTIONS.REDIRECT]\n    });\n    this.state.privKey = res.privKey;\n    return res;\n  }\n\n  async login(params) {\n    if (params !== null && params !== void 0 && params.loginProvider) {\n      return this._selectedLogin(params);\n    }\n\n    return this._modal(params);\n  }\n\n  async _selectedLogin(params) {\n    const defaultParams = {\n      redirectUrl: this.state.redirectUrl\n    };\n\n    const loginParams = _objectSpread(_objectSpread({\n      loginProvider: params.loginProvider\n    }, defaultParams), params); // fast login flow\n    // if (this.state.store.get(\"touchIDPreference\") === \"enabled\" && !loginParams.extraLoginOptions?.login_hint) {\n    //   return this._fastLogin(loginParams);\n    // }\n\n\n    const res = await this.request({\n      method: OPENLOGIN_METHOD.LOGIN,\n      allowedInteractions: [UX_MODE.REDIRECT, UX_MODE.POPUP],\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      params: [loginParams]\n    });\n    this.state.privKey = res.privKey;\n\n    if (res.store) {\n      this._syncState(res);\n    } else if (this.state.privKey && this.state.support3PC) {\n      this._syncState(await this._getData());\n    }\n\n    return {\n      privKey: this.privKey\n    };\n  }\n\n  async logout() {\n    let logoutParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const params = {}; // defaults\n\n    params.redirectUrl = this.state.redirectUrl;\n    params._clientId = this.state.clientId;\n\n    if (logoutParams.clientId) {\n      params._clientId = logoutParams.clientId;\n    }\n\n    if (logoutParams.fastLogin !== undefined) {\n      params.fastLogin = logoutParams.fastLogin;\n    }\n\n    if (logoutParams.redirectUrl !== undefined) {\n      params.redirectUrl = logoutParams.redirectUrl;\n    }\n\n    const res = await this.request({\n      method: OPENLOGIN_METHOD.LOGOUT,\n      params: [params],\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC, ALLOWED_INTERACTIONS.POPUP, ALLOWED_INTERACTIONS.REDIRECT]\n    });\n    this.state.privKey = \"\"; // if (!params.fastLogin) this.state.store.set(\"touchIDPreference\", \"disabled\");\n\n    return res;\n  }\n\n  async request(args) {\n    var _params$0$redirectUrl;\n\n    const pid = randomId();\n    let {\n      params\n    } = args; // Note: _origin is added later in postMessageStream for jrpc requests\n    // do not add it here since its used for checking postMessage constraints\n\n    const session = {};\n    if (params.length !== 1) throw new Error(\"request params array should have only one element\");\n    const {\n      startUrl,\n      popupUrl,\n      method,\n      allowedInteractions\n    } = args;\n    if (allowedInteractions.length === 0) throw new Error(\"no allowed interactions\");\n\n    if (this.state.clientId) {\n      session._clientId = this.state.clientId;\n    }\n\n    if (this.privKey) {\n      const userData = {\n        clientId: session._clientId,\n        timestamp: Date.now().toString()\n      };\n      const sig = await sign(Buffer.from(this.privKey, \"hex\"), Buffer.from(keccak(\"keccak256\").update(JSON.stringify(userData)).digest(\"hex\"), \"hex\"));\n      session._user = getPublic(Buffer.from(this.privKey, \"hex\")).toString(\"hex\");\n      session._userSig = base64url.encode(sig);\n      session._userData = userData;\n    }\n\n    session._originData = this.state.originData;\n    session._whiteLabelData = this.state.whiteLabel;\n    session._loginConfig = this.state.loginConfig; // add in session data (allow overrides)\n\n    params = [_objectSpread(_objectSpread({}, session), params[0])]; // use JRPC where possible\n\n    if (this.state.support3PC && allowedInteractions.includes(ALLOWED_INTERACTIONS.JRPC)) {\n      return this._jrpcRequest({\n        method,\n        params\n      });\n    } // set origin\n\n\n    params[0]._origin = new URL((_params$0$redirectUrl = params[0].redirectUrl) !== null && _params$0$redirectUrl !== void 0 ? _params$0$redirectUrl : this.state.redirectUrl).origin; // preset params\n\n    if (this.state.support3PC) {\n      // set params first if 3PC supported\n      await this._setPIDData(pid, params); // eslint-disable-next-line require-atomic-updates\n\n      params = [{}];\n    }\n\n    if (!startUrl || !popupUrl) {\n      throw new Error(\"no url for redirect / popup flow\");\n    } // method and pid are always in URL hash params\n    // convert params from JSON to base64\n\n\n    if (this.state.uxMode === UX_MODE.REDIRECT) {\n      // if redirects preferred, check for redirect flows first, then check for popup flow\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n        // give time for synchronous methods to complete before redirect\n        setTimeout(() => {\n          window.location.href = constructURL({\n            baseURL: startUrl,\n            hash: {\n              b64Params: jsonToBase64(params[0]),\n              _pid: pid,\n              _method: method\n            }\n          });\n        }, 50);\n        return {};\n      }\n\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n        const u = new URL(constructURL({\n          baseURL: popupUrl,\n          hash: {\n            b64Params: jsonToBase64(params[0]),\n            _pid: pid,\n            _method: method\n          }\n        }));\n        const windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n        return awaitReq(pid, windowRef);\n      }\n    } else {\n      // if popups preferred, check for popup flows first, then check for redirect flow\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n        const u = new URL(constructURL({\n          baseURL: popupUrl,\n          hash: {\n            b64Params: jsonToBase64(params[0]),\n            _pid: pid,\n            _method: method\n          }\n        }));\n        const windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n        return awaitReq(pid, windowRef);\n      }\n\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n        // give time for synchronous methods to complete before redirect\n        setTimeout(() => {\n          window.location.href = constructURL({\n            baseURL: startUrl,\n            hash: {\n              b64Params: jsonToBase64(params[0]),\n              _pid: pid,\n              _method: method\n            }\n          });\n        }, 50);\n        return null;\n      }\n    }\n\n    throw new Error(\"no matching allowed interactions\");\n  }\n\n  async _jrpcRequest(args) {\n    // await this.initialized;\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw new Error(\"invalid request args\");\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw new Error(\"invalid request method\");\n    }\n\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error(\"invalid request params\");\n    }\n\n    if (params.length === 0) {\n      params.push({});\n    }\n\n    return new Promise((resolve, reject) => {\n      this.provider._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n\n  async _check3PCSupport() {\n    return this._jrpcRequest({\n      method: OPENLOGIN_METHOD.CHECK_3PC_SUPPORT,\n      params: [{\n        _originData: this.state.originData\n      }]\n    });\n  }\n\n  async _setPIDData(pid, data) {\n    await this.request({\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n      method: OPENLOGIN_METHOD.SET_PID_DATA,\n      params: [{\n        pid,\n        data: data[0]\n      }]\n    });\n  }\n\n  async _getData() {\n    return this.request({\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n      method: OPENLOGIN_METHOD.GET_DATA,\n      params: [{}]\n    });\n  }\n\n  _syncState(newState) {\n    if (newState.store) {\n      if (typeof newState.store !== \"object\") {\n        throw new Error(\"expected store to be an object\");\n      }\n\n      Object.keys(newState.store).forEach(key => {\n        // if privKey is available then user is not logged out, but in popup mode store info is not available.\n        // so we don't want to overwrite the local store if privKey is available\n        // and if latest iframe store data is not available\n        if (newState.privKey) {\n          if (newState.store[key]) {\n            this.state.store.set(key, newState.store[key]);\n          }\n        } else {\n          this.state.store.set(key, newState.store[key]);\n        }\n      });\n    }\n\n    const {\n      store\n    } = this.state;\n    this.state = _objectSpread(_objectSpread(_objectSpread({}, this.state), newState), {}, {\n      store\n    });\n  }\n\n  async _modal(params) {\n    return new Promise((resolve, reject) => {\n      this.modal._prompt(this.state.clientId, this.state.whiteLabel, this.state.loginConfig, async chunk => {\n        if (chunk.cancel) {\n          reject(new Error(\"user canceled login\"));\n        } else {\n          try {\n            const selectedLoginResponse = await this._selectedLogin(merge(params, chunk));\n            resolve(selectedLoginResponse);\n          } catch (error) {\n            reject(error);\n          }\n        }\n      });\n    });\n  }\n\n  async _cleanup() {\n    await this.modal.cleanup();\n    this.provider.cleanup();\n  }\n\n  async encrypt(message, privateKey) {\n    let privKey = privateKey;\n\n    if (!privKey) {\n      privKey = this.privKey;\n    } // validations\n\n\n    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n      if (privKey === \"\" || privKey === undefined) {\n        throw new Error(\"private key cannot be empty\");\n      } else {\n        throw new Error(\"invalid private key in encrypt\");\n      }\n    }\n\n    return encrypt(getPublic(Buffer.from(privKey, \"hex\")), message);\n  }\n\n  async decrypt(ciphertext, privateKey) {\n    let privKey = privateKey;\n\n    if (!privKey) {\n      privKey = this.privKey;\n    } // validations\n\n\n    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n      if (privKey === \"\" || privKey === undefined) {\n        throw new Error(\"private key cannot be empty\");\n      } else {\n        throw new Error(\"invalid private key in decrypt\");\n      }\n    }\n\n    return decrypt(Buffer.from(privKey, \"hex\"), ciphertext);\n  }\n\n  async getUserInfo() {\n    if (this.privKey) {\n      const storeData = this.state.store.getStore();\n      const userInfo = {\n        email: storeData.email || \"\",\n        name: storeData.name || \"\",\n        profileImage: storeData.profileImage || \"\",\n        aggregateVerifier: storeData.aggregateVerifier || \"\",\n        verifier: storeData.verifier || \"\",\n        verifierId: storeData.verifierId || \"\",\n        typeOfLogin: storeData.typeOfLogin || \"\",\n        dappShare: storeData.dappShare || \"\"\n      };\n      return userInfo;\n    }\n\n    throw new Error(\"user should be logged in to fetch userInfo\");\n  }\n\n  async getEncodedLoginUrl(loginParams) {\n    const {\n      redirectUrl\n    } = loginParams;\n    const {\n      clientId\n    } = this.state;\n\n    if (!this.state.originData[origin]) {\n      await this.updateOriginData();\n    }\n\n    const dataObject = _objectSpread({\n      _clientId: clientId,\n      _origin: new URL(redirectUrl).origin,\n      _originData: this.state.originData,\n      redirectUrl\n    }, loginParams);\n\n    const b64Params = jsonToBase64(dataObject);\n    const hashParams = {\n      b64Params,\n      _method: \"openlogin_login\"\n    };\n    return constructURL({\n      baseURL: \"\".concat(this.state.iframeUrl, \"/start\"),\n      hash: hashParams\n    });\n  }\n\n}\n\nexport { ALLOWED_INTERACTIONS, LOGIN_PROVIDER, MFA_LEVELS, OPENLOGIN_METHOD, OPENLOGIN_NETWORK, OpenLoginStore, Provider, UX_MODE, awaitReq, constructURL, OpenLogin as default, documentReady, getHashQueryParams, getPopupFeatures, htmlToElement, localStorageAvailable, log as loglevel, modalDOMElementID, preloadIframe, sessionStorageAvailable, storageAvailable, storeKey, whitelistUrl };\n//# sourceMappingURL=openlogin.esm.js.map\n"]},"metadata":{},"sourceType":"module"}