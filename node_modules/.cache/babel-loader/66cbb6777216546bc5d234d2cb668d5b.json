{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-bitwise */\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError(\"Tried to encode large digit \".concat(number, \" in base64.\"));\n}\n\nfunction encodeBase64(bytes\n/*: Array<number>*/\n)\n/*: string*/\n{\n  var chunks = [];\n  chunks.length = Math.ceil(bytes.length / 3);\n\n  for (var i = 0; i < chunks.length; i++) {\n    var b1 = bytes[i * 3];\n    var b2 = bytes[i * 3 + 1] || 0;\n    var b3 = bytes[i * 3 + 2] || 0;\n    var has2 = i * 3 + 1 < bytes.length;\n    var has3 = i * 3 + 2 < bytes.length;\n    chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n  }\n\n  return chunks.join('');\n}\n\nmodule.exports = {\n  encodeBase64: encodeBase64,\n  b64Digit: b64Digit\n};","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/Twitter-Start/node_modules/moralis/lib/browser/ParseFileEncode.js"],"names":["b64Digit","number","String","fromCharCode","TypeError","concat","encodeBase64","bytes","chunks","length","Math","ceil","i","b1","b2","b3","has2","has3","join","module","exports"],"mappings":"AAAA;AACA;;AAEA,SAASA,QAAT,CAAkBC;AAClB;AADA;AAGA;AACA;AACE,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,KAAKF,MAAzB,CAAP;AACD;;AAED,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,MAAMF,MAAM,GAAG,EAAf,CAApB,CAAP;AACD;;AAED,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,MAAMF,MAAM,GAAG,EAAf,CAApB,CAAP;AACD;;AAED,MAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,WAAO,GAAP;AACD;;AAED,MAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,WAAO,GAAP;AACD;;AAED,QAAM,IAAIG,SAAJ,CAAc,+BAA+BC,MAA/B,CAAsCJ,MAAtC,EAA8C,aAA9C,CAAd,CAAN;AACD;;AAED,SAASK,YAAT,CAAsBC;AACtB;AADA;AAGA;AACA;AACE,MAAIC,MAAM,GAAG,EAAb;AACAA,EAAAA,MAAM,CAACC,MAAP,GAAgBC,IAAI,CAACC,IAAL,CAAUJ,KAAK,CAACE,MAAN,GAAe,CAAzB,CAAhB;;AAEA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACC,MAA3B,EAAmCG,CAAC,EAApC,EAAwC;AACtC,QAAIC,EAAE,GAAGN,KAAK,CAACK,CAAC,GAAG,CAAL,CAAd;AACA,QAAIE,EAAE,GAAGP,KAAK,CAACK,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL,IAAoB,CAA7B;AACA,QAAIG,EAAE,GAAGR,KAAK,CAACK,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL,IAAoB,CAA7B;AACA,QAAII,IAAI,GAAGJ,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAYL,KAAK,CAACE,MAA7B;AACA,QAAIQ,IAAI,GAAGL,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAYL,KAAK,CAACE,MAA7B;AACAD,IAAAA,MAAM,CAACI,CAAD,CAAN,GAAY,CAACZ,QAAQ,CAACa,EAAE,IAAI,CAAN,GAAU,IAAX,CAAT,EAA2Bb,QAAQ,CAACa,EAAE,IAAI,CAAN,GAAU,IAAV,GAAiBC,EAAE,IAAI,CAAN,GAAU,IAA5B,CAAnC,EAAsEE,IAAI,GAAGhB,QAAQ,CAACc,EAAE,IAAI,CAAN,GAAU,IAAV,GAAiBC,EAAE,IAAI,CAAN,GAAU,IAA5B,CAAX,GAA+C,GAAzH,EAA8HE,IAAI,GAAGjB,QAAQ,CAACe,EAAE,GAAG,IAAN,CAAX,GAAyB,GAA3J,EAAgKG,IAAhK,CAAqK,EAArK,CAAZ;AACD;;AAED,SAAOV,MAAM,CAACU,IAAP,CAAY,EAAZ,CAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACfd,EAAAA,YAAY,EAAEA,YADC;AAEfN,EAAAA,QAAQ,EAAEA;AAFK,CAAjB","sourcesContent":["\"use strict\";\n/* eslint-disable no-bitwise */\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError(\"Tried to encode large digit \".concat(number, \" in base64.\"));\n}\n\nfunction encodeBase64(bytes\n/*: Array<number>*/\n)\n/*: string*/\n{\n  var chunks = [];\n  chunks.length = Math.ceil(bytes.length / 3);\n\n  for (var i = 0; i < chunks.length; i++) {\n    var b1 = bytes[i * 3];\n    var b2 = bytes[i * 3 + 1] || 0;\n    var b3 = bytes[i * 3 + 2] || 0;\n    var has2 = i * 3 + 1 < bytes.length;\n    var has3 = i * 3 + 2 < bytes.length;\n    chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n  }\n\n  return chunks.join('');\n}\n\nmodule.exports = {\n  encodeBase64: encodeBase64,\n  b64Digit: b64Digit\n};"]},"metadata":{},"sourceType":"script"}