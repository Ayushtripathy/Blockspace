{"ast":null,"code":"import _isTypedArray from \"is-typedarray\";\nimport typedArrayToBuffer from \"typedarray-to-buffer\";\nconst ENC_HEX = \"hex\";\nconst ENC_UTF8 = \"utf8\";\nconst ENC_BIN = \"binary\";\nconst TYPE_BUFFER = \"buffer\";\nconst TYPE_ARRAY = \"array\";\nconst TYPE_TYPED_ARRAY = \"typed-array\";\nconst TYPE_ARRAY_BUFFER = \"array-buffer\";\nconst STRING_ZERO = \"0\";\nexport function bufferToArray(buf) {\n  return new Uint8Array(buf);\n}\nexport function bufferToHex(buf) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const hex = buf.toString(ENC_HEX);\n  return prefixed ? addHexPrefix(hex) : hex;\n}\nexport function bufferToUtf8(buf) {\n  return buf.toString(ENC_UTF8);\n}\nexport function bufferToNumber(buf) {\n  return buf.readUIntBE(0, buf.length);\n}\nexport function bufferToBinary(buf) {\n  return arrayToBinary(bufferToArray(buf));\n}\nexport function arrayToBuffer(arr) {\n  return typedArrayToBuffer(arr);\n}\nexport function arrayToHex(arr) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return bufferToHex(arrayToBuffer(arr), prefixed);\n}\nexport function arrayToUtf8(arr) {\n  return bufferToUtf8(arrayToBuffer(arr));\n}\nexport function arrayToNumber(arr) {\n  return bufferToNumber(arrayToBuffer(arr));\n}\nexport function arrayToBinary(arr) {\n  return Array.from(arr).map(numberToBinary).join(\"\");\n}\nexport function hexToBuffer(hex) {\n  return Buffer.from(removeHexPrefix(hex), ENC_HEX);\n}\nexport function hexToArray(hex) {\n  return bufferToArray(hexToBuffer(hex));\n}\nexport function hexToUtf8(hex) {\n  return bufferToUtf8(hexToBuffer(hex));\n}\nexport function hexToNumber(hex) {\n  return arrayToNumber(hexToArray(hex));\n}\nexport function hexToBinary(hex) {\n  return arrayToBinary(hexToArray(hex));\n}\nexport function utf8ToBuffer(utf8) {\n  return Buffer.from(utf8, ENC_UTF8);\n}\nexport function utf8ToArray(utf8) {\n  return bufferToArray(utf8ToBuffer(utf8));\n}\nexport function utf8ToHex(utf8) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return bufferToHex(utf8ToBuffer(utf8), prefixed);\n}\nexport function utf8ToNumber(utf8) {\n  const num = parseInt(utf8, 10);\n  assert(isDefined(num), \"Number can only safely store up to 53 bits\");\n  return num;\n}\nexport function utf8ToBinary(utf8) {\n  return arrayToBinary(utf8ToArray(utf8));\n}\nexport function numberToBuffer(num) {\n  return binaryToBuffer(numberToBinary(num));\n}\nexport function numberToArray(num) {\n  return binaryToArray(numberToBinary(num));\n}\nexport function numberToHex(num, prefixed) {\n  return binaryToHex(numberToBinary(num), prefixed);\n}\nexport function numberToUtf8(num) {\n  return `${num}`;\n}\nexport function numberToBinary(num) {\n  const bin = (num >>> 0).toString(2);\n  return sanitizeBytes(bin);\n}\nexport function binaryToBuffer(bin) {\n  return arrayToBuffer(binaryToArray(bin));\n}\nexport function binaryToArray(bin) {\n  return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));\n}\nexport function binaryToHex(bin, prefixed) {\n  return arrayToHex(binaryToArray(bin), prefixed);\n}\nexport function binaryToUtf8(bin) {\n  return arrayToUtf8(binaryToArray(bin));\n}\nexport function binaryToNumber(bin) {\n  return arrayToNumber(binaryToArray(bin));\n}\nexport function isBinaryString(str) {\n  if (typeof str !== \"string\" || !new RegExp(/^[01]+$/).test(str)) {\n    return false;\n  }\n\n  if (str.length % 8 !== 0) {\n    return false;\n  }\n\n  return true;\n}\nexport function isHexString(str, length) {\n  if (typeof str !== \"string\" || !str.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && str.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\nexport function isBuffer(val) {\n  return Buffer.isBuffer(val);\n}\nexport function isTypedArray(val) {\n  return _isTypedArray.strict(val) && !isBuffer(val);\n}\nexport function isArrayBuffer(val) {\n  return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== \"undefined\";\n}\nexport function getType(val) {\n  if (isBuffer(val)) {\n    return TYPE_BUFFER;\n  } else if (isTypedArray(val)) {\n    return TYPE_TYPED_ARRAY;\n  } else if (isArrayBuffer(val)) {\n    return TYPE_ARRAY_BUFFER;\n  } else if (Array.isArray(val)) {\n    return TYPE_ARRAY;\n  } else {\n    return typeof val;\n  }\n}\nexport function getEncoding(str) {\n  if (isBinaryString(str)) {\n    return ENC_BIN;\n  }\n\n  if (isHexString(str)) {\n    return ENC_HEX;\n  }\n\n  return ENC_UTF8;\n}\nexport function concatBuffers() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  const result = Buffer.concat(args);\n  return result;\n}\nexport function concatArrays() {\n  let result = [];\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  args.forEach(arg => result = result.concat(Array.from(arg)));\n  return new Uint8Array([...result]);\n}\nexport function trimLeft(data, length) {\n  const diff = data.length - length;\n\n  if (diff > 0) {\n    data = data.slice(diff);\n  }\n\n  return data;\n}\nexport function trimRight(data, length) {\n  return data.slice(0, length);\n}\nexport function calcByteLength(length) {\n  let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nexport function splitBytes(str) {\n  let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, \"gi\"));\n  return Array.from(bytes || []);\n}\nexport function swapBytes(str) {\n  return splitBytes(str).map(reverseString).join(\"\");\n}\nexport function swapHex(str) {\n  return binaryToHex(swapBytes(hexToBinary(str)));\n}\nexport function sanitizeBytes(str) {\n  let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padLeft(str, calcByteLength(str.length, byteSize), padding);\n}\nexport function padLeft(str, length) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padString(str, length, true, padding);\n}\nexport function padRight(str, length) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padString(str, length, false, padding);\n}\nexport function removeHexPrefix(hex) {\n  return hex.replace(/^0x/, \"\");\n}\nexport function addHexPrefix(hex) {\n  return hex.startsWith(\"0x\") ? hex : `0x${hex}`;\n}\nexport function sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n\n  return hex;\n}\nexport function removeHexLeadingZeros(hex) {\n  const prefixed = hex.startsWith(\"0x\");\n  hex = removeHexPrefix(hex);\n  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;\n  return prefixed ? addHexPrefix(hex) : hex;\n}\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n\nfunction isDefined(value) {\n  return !isUndefined(value);\n}\n\nfunction assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\");\n}\n\nfunction padString(str, length, left) {\n  let padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STRING_ZERO;\n  const diff = length - str.length;\n  let result = str;\n\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _isTypedArray from \"is-typedarray\";\nimport typedArrayToBuffer from \"typedarray-to-buffer\";\nconst ENC_HEX = \"hex\";\nconst ENC_UTF8 = \"utf8\";\nconst ENC_BIN = \"binary\";\nconst TYPE_BUFFER = \"buffer\";\nconst TYPE_ARRAY = \"array\";\nconst TYPE_TYPED_ARRAY = \"typed-array\";\nconst TYPE_ARRAY_BUFFER = \"array-buffer\";\nconst STRING_ZERO = \"0\";\nexport function bufferToArray(buf) {\n    return new Uint8Array(buf);\n}\nexport function bufferToHex(buf, prefixed = false) {\n    const hex = buf.toString(ENC_HEX);\n    return prefixed ? addHexPrefix(hex) : hex;\n}\nexport function bufferToUtf8(buf) {\n    return buf.toString(ENC_UTF8);\n}\nexport function bufferToNumber(buf) {\n    return buf.readUIntBE(0, buf.length);\n}\nexport function bufferToBinary(buf) {\n    return arrayToBinary(bufferToArray(buf));\n}\nexport function arrayToBuffer(arr) {\n    return typedArrayToBuffer(arr);\n}\nexport function arrayToHex(arr, prefixed = false) {\n    return bufferToHex(arrayToBuffer(arr), prefixed);\n}\nexport function arrayToUtf8(arr) {\n    return bufferToUtf8(arrayToBuffer(arr));\n}\nexport function arrayToNumber(arr) {\n    return bufferToNumber(arrayToBuffer(arr));\n}\nexport function arrayToBinary(arr) {\n    return Array.from(arr)\n        .map(numberToBinary)\n        .join(\"\");\n}\nexport function hexToBuffer(hex) {\n    return Buffer.from(removeHexPrefix(hex), ENC_HEX);\n}\nexport function hexToArray(hex) {\n    return bufferToArray(hexToBuffer(hex));\n}\nexport function hexToUtf8(hex) {\n    return bufferToUtf8(hexToBuffer(hex));\n}\nexport function hexToNumber(hex) {\n    return arrayToNumber(hexToArray(hex));\n}\nexport function hexToBinary(hex) {\n    return arrayToBinary(hexToArray(hex));\n}\nexport function utf8ToBuffer(utf8) {\n    return Buffer.from(utf8, ENC_UTF8);\n}\nexport function utf8ToArray(utf8) {\n    return bufferToArray(utf8ToBuffer(utf8));\n}\nexport function utf8ToHex(utf8, prefixed = false) {\n    return bufferToHex(utf8ToBuffer(utf8), prefixed);\n}\nexport function utf8ToNumber(utf8) {\n    const num = parseInt(utf8, 10);\n    assert(isDefined(num), \"Number can only safely store up to 53 bits\");\n    return num;\n}\nexport function utf8ToBinary(utf8) {\n    return arrayToBinary(utf8ToArray(utf8));\n}\nexport function numberToBuffer(num) {\n    return binaryToBuffer(numberToBinary(num));\n}\nexport function numberToArray(num) {\n    return binaryToArray(numberToBinary(num));\n}\nexport function numberToHex(num, prefixed) {\n    return binaryToHex(numberToBinary(num), prefixed);\n}\nexport function numberToUtf8(num) {\n    return `${num}`;\n}\nexport function numberToBinary(num) {\n    const bin = (num >>> 0).toString(2);\n    return sanitizeBytes(bin);\n}\nexport function binaryToBuffer(bin) {\n    return arrayToBuffer(binaryToArray(bin));\n}\nexport function binaryToArray(bin) {\n    return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));\n}\nexport function binaryToHex(bin, prefixed) {\n    return arrayToHex(binaryToArray(bin), prefixed);\n}\nexport function binaryToUtf8(bin) {\n    return arrayToUtf8(binaryToArray(bin));\n}\nexport function binaryToNumber(bin) {\n    return arrayToNumber(binaryToArray(bin));\n}\nexport function isBinaryString(str) {\n    if (typeof str !== \"string\" || !new RegExp(/^[01]+$/).test(str)) {\n        return false;\n    }\n    if (str.length % 8 !== 0) {\n        return false;\n    }\n    return true;\n}\nexport function isHexString(str, length) {\n    if (typeof str !== \"string\" || !str.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && str.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexport function isBuffer(val) {\n    return Buffer.isBuffer(val);\n}\nexport function isTypedArray(val) {\n    return _isTypedArray.strict(val) && !isBuffer(val);\n}\nexport function isArrayBuffer(val) {\n    return (!isTypedArray(val) &&\n        !isBuffer(val) &&\n        typeof val.byteLength !== \"undefined\");\n}\nexport function getType(val) {\n    if (isBuffer(val)) {\n        return TYPE_BUFFER;\n    }\n    else if (isTypedArray(val)) {\n        return TYPE_TYPED_ARRAY;\n    }\n    else if (isArrayBuffer(val)) {\n        return TYPE_ARRAY_BUFFER;\n    }\n    else if (Array.isArray(val)) {\n        return TYPE_ARRAY;\n    }\n    else {\n        return typeof val;\n    }\n}\nexport function getEncoding(str) {\n    if (isBinaryString(str)) {\n        return ENC_BIN;\n    }\n    if (isHexString(str)) {\n        return ENC_HEX;\n    }\n    return ENC_UTF8;\n}\nexport function concatBuffers(...args) {\n    const result = Buffer.concat(args);\n    return result;\n}\nexport function concatArrays(...args) {\n    let result = [];\n    args.forEach(arg => (result = result.concat(Array.from(arg))));\n    return new Uint8Array([...result]);\n}\nexport function trimLeft(data, length) {\n    const diff = data.length - length;\n    if (diff > 0) {\n        data = data.slice(diff);\n    }\n    return data;\n}\nexport function trimRight(data, length) {\n    return data.slice(0, length);\n}\nexport function calcByteLength(length, byteSize = 8) {\n    const remainder = length % byteSize;\n    return remainder\n        ? ((length - remainder) / byteSize) * byteSize + byteSize\n        : length;\n}\nexport function splitBytes(str, byteSize = 8) {\n    const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, \"gi\"));\n    return Array.from(bytes || []);\n}\nexport function swapBytes(str) {\n    return splitBytes(str)\n        .map(reverseString)\n        .join(\"\");\n}\nexport function swapHex(str) {\n    return binaryToHex(swapBytes(hexToBinary(str)));\n}\nexport function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str.length, byteSize), padding);\n}\nexport function padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nexport function padRight(str, length, padding = STRING_ZERO) {\n    return padString(str, length, false, padding);\n}\nexport function removeHexPrefix(hex) {\n    return hex.replace(/^0x/, \"\");\n}\nexport function addHexPrefix(hex) {\n    return hex.startsWith(\"0x\") ? hex : `0x${hex}`;\n}\nexport function sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nexport function removeHexLeadingZeros(hex) {\n    const prefixed = hex.startsWith(\"0x\");\n    hex = removeHexPrefix(hex);\n    hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;\n    return prefixed ? addHexPrefix(hex) : hex;\n}\nfunction isUndefined(value) {\n    return typeof value === \"undefined\";\n}\nfunction isDefined(value) {\n    return !isUndefined(value);\n}\nfunction assert(assertion, errorMessage) {\n    if (!assertion) {\n        throw new Error(errorMessage);\n    }\n}\nfunction reverseString(str) {\n    return str\n        .split(\"\")\n        .reverse()\n        .join(\"\");\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}