{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\n\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\n\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\n\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };","map":{"version":3,"sources":["../src/rpc/solanaRpcMiddlewares.ts","../src/providers/injectedProviders/injectedProviderProxy.ts","../src/providers/injectedProviders/phantom/providerHandlers.ts","../src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","../src/providers/injectedProviders/torus/providerHandlers.ts","../src/providers/injectedProviders/torus/torusInjectedProvider.ts","../src/rpc/JrpcClient.ts","../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","../src/solanaWallet.ts"],"names":["createGetAccountsMiddleware","getAccounts","createAsyncMiddleware","method","next","accounts","response","createRequestAccountsMiddleware","requestAccounts","createGenericJRPCMiddleware","targetMethod","handler","result","createSolanaMiddleware","providerHandlers","getPrivateKey","mergeMiddleware","createChainSwitchMiddleware","switchSolanaChain","createAccountMiddleware","updatePrivatekey","createInjectedProviderProxyMiddleware","provider","res","getPhantomHandlers","injectedProvider","bs58","ethErrors","signTransaction","message","req","txn","Transaction","transaction","signMessage","params","signAndSendTransaction","txRes","signature","signAllTransactions","txns","msg","decodedMsg","PhantomInjectedProvider","BaseProvider","constructor","state","config","chainConfig","chainNamespace","CHAIN_NAMESPACES","SOLANA","switchChain","Promise","setupProvider","solanaMiddleware","injectedProviderProxy","engine","providerFromEngine","lookupNetwork","chainId","getTorusHandlers","data","buf","Buffer","sendTx","messages","TorusInjectedProvider","code","connectedChainId","connectedHexChainId","isHexStrict","parseInt","WalletInitializationError","setupEngine","handleInjectedProviderUpdate","createChainIdMiddleware","end","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","getProviderEngineProxy","transactionGenerator","serializedTx","decodedTx","tx","Message","keyPairGenerator","Keypair","keyPair","signedMsg","nacl","_providerEngineProxy","sig","signedTransactions","SolanaPrivateKeyProvider","providerFactory","enable","getProviderHandlers","updateAccount","existingKey","privKey","health","getChainSwitchMiddleware","chainSwitchHandlers","addNewChainConfig","nativeCurrency","rpcUrls","ticker","tickerName","displayName","blockExplorer","chainSwitchMiddleware","getAccountMiddleware","accountHandlers","privateKey","SolanaWallet","requireAllSignatures","signedTransaction","request"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}