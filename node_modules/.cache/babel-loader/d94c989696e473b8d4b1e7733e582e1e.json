{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\n\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId)), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    return this.walletAdapters[walletName].connect(loginParams);\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n\n      if (storageAvailable(\"sessionStorage\")) {\n        const cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthCore };","map":{"version":3,"sources":["../src/core.ts"],"names":["ADAPTER_CACHE_KEY","Web3AuthCore","SafeEventEmitter","ADAPTER_STATUS","NOT_READY","constructor","options","Object","WalletInitializationError","storageAvailable","window","chainConfig","getChainConfig","provider","adapter","init","initPromises","adapterName","providedChainConfig","autoConnect","e","log","Promise","configureAdapter","adapterAlreadyExists","ADAPTER_NAMESPACES","clearCache","connectTo","logout","cleanup","WalletLoginError","getUserInfo","subscribeToAdapterEvents","walletAdapter","ADAPTER_EVENTS","data","cachedAdapter","checkInitRequirements","cacheWallet"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId)), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    return this.walletAdapters[walletName].connect(loginParams);\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n\n      if (storageAvailable(\"sessionStorage\")) {\n        const cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthCore };\n//# sourceMappingURL=core.esm.js.map\n"]},"metadata":{},"sourceType":"module"}