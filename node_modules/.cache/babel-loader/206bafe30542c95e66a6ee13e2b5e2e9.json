{"ast":null,"code":"\"use strict\";\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\n\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\n\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n        _step;\n\n    try {\n      var _loop = function () {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n            operation = _step$value[0],\n            group = _step$value[1];\n\n        _this.permissionsMap[operation] = _objectSpread({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n            operation = _step2$value[0],\n            group = _step2$value[1];\n\n        this.permissionsMap[operation] = _objectSpread({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (var user in users) {\n            var allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseCLP*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string*/\n    {\n      var name = role;\n\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function (entity\n    /*: Entity*/\n    ) {\n      var userId = entity;\n\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      userId = this._parseEntity(userId);\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        }\n\n        this.permissionsMap[permission][userId] = {};\n      }\n\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    )\n    /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n\n        return !!this.permissionsMap[permission][userId];\n      }\n\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , fields\n    /*: string*/\n    ) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function (operation\n    /*: string*/\n    , pointerFields\n    /*: string[]*/\n    ) {\n      var fields = this.permissionsMap[operation];\n\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function (operation\n    /*: string*/\n    )\n    /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setReadUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getReadUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setWriteUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getWriteUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n\n  }, {\n    key: \"setProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    , fields\n    /*: string[]*/\n    ) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('find', userId, allowed);\n\n      this._setAccess('get', userId, allowed);\n\n      this._setAccess('count', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('create', userId, allowed);\n\n      this._setAccess('update', userId, allowed);\n\n      this._setAccess('delete', userId, allowed);\n\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function (fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    , fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\n\nvar _default = ParseCLP;\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/Twitter-Start/node_modules/moralis/lib/browser/ParseCLP.js"],"names":["_sliceInstanceProperty2","require","_Array$from","_Symbol","_getIteratorMethod","_Array$isArray2","_Object$keys2","_Object$getOwnPropertySymbols","_filterInstanceProperty","_Object$getOwnPropertyDescriptor","_forEachInstanceProperty","_Object$getOwnPropertyDescriptors","_Object$defineProperties","_Object$defineProperty","_interopRequireDefault","exports","value","default","_slicedToArray2","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_map","_includes","_every","_entries","_slice","_keys","_isArray","_ParseRole","_ParseUser","ownKeys","object","enumerableOnly","keys","symbols","call","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","_context3","_context4","source","Object","key","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","return","minLen","_context2","_arrayLikeToArray","prototype","toString","constructor","name","test","arr","len","arr2","Array","PUBLIC_KEY","VALID_PERMISSIONS","set","VALID_PERMISSIONS_EXTENDED","ParseCLP","userId","_this","permissionsMap","_iterator","_step","_loop","_step$value","operation","group","action","charAt","toUpperCase","concat","_getAccess","allowed","_setAccess","pointerFields","_setArrayAccess","entity","role","_getRoleName","_iterator2","_step2","_step2$value","setReadAccess","setWriteAccess","setRoleReadAccess","setRoleWriteAccess","_permission","_context","users","isValidPermission","get","isValidPermissionExtended","isValidGroupPermission","pointer","user","other","permissions","otherPermissions","_permission2","otherUsers","getName","id","Error","permission","_parseEntity","returnBoolean","undefined","fields","field","_setGroupPointerPermission","_getGroupPointerPermissions","getReadAccess","getWriteAccess","setProtectedFields","getProtectedFields","_default"],"mappings":"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/B,EAAkD,EAAlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIE,QAAQ,GAAG,aAAa,YAAY;AACtC;AACF;AACA;AACE,WAASA,QAAT,CAAkBC;AAClB;AADA,IAEE;AACA,QAAIC,KAAK,GAAG,IAAZ;;AAEA,KAAC,GAAGtE,gBAAgB,CAACH,OAArB,EAA8B,IAA9B,EAAoCuE,QAApC;AACA,KAAC,GAAGlE,gBAAgB,CAACL,OAArB,EAA8B,IAA9B,EAAoC,gBAApC,EAAsD,KAAK,CAA3D;AACA,SAAK0E,cAAL,GAAsB,EAAtB,CALA,CAK0B;;AAE1B,QAAIC,SAAS,GAAGxC,0BAA0B,CAAC,CAAC,GAAG1B,QAAQ,CAACT,OAAb,EAAsBoE,iBAAtB,EAAyChD,IAAzC,CAA8CgD,iBAA9C,CAAD,CAA1C;AAAA,QACIQ,KADJ;;AAGA,QAAI;AACF,UAAIC,KAAK,GAAG,YAAY;AACtB,YAAIC,WAAW,GAAG,CAAC,GAAG7E,eAAe,CAACD,OAApB,EAA6B4E,KAAK,CAAC7E,KAAnC,EAA0C,CAA1C,CAAlB;AAAA,YACIgF,SAAS,GAAGD,WAAW,CAAC,CAAD,CAD3B;AAAA,YAEIE,KAAK,GAAGF,WAAW,CAAC,CAAD,CAFvB;;AAIAL,QAAAA,KAAK,CAACC,cAAN,CAAqBK,SAArB,IAAkCtD,aAAa,CAAC,EAAD,EAAKuD,KAAL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","sourcesContent":["\"use strict\";\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\n\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\n\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n        _step;\n\n    try {\n      var _loop = function () {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n            operation = _step$value[0],\n            group = _step$value[1];\n\n        _this.permissionsMap[operation] = _objectSpread({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n            operation = _step2$value[0],\n            group = _step2$value[1];\n\n        this.permissionsMap[operation] = _objectSpread({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (var user in users) {\n            var allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseCLP*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string*/\n    {\n      var name = role;\n\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function (entity\n    /*: Entity*/\n    ) {\n      var userId = entity;\n\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      userId = this._parseEntity(userId);\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        }\n\n        this.permissionsMap[permission][userId] = {};\n      }\n\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    )\n    /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n\n        return !!this.permissionsMap[permission][userId];\n      }\n\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function (permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , fields\n    /*: string*/\n    ) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function (operation\n    /*: string*/\n    , pointerFields\n    /*: string[]*/\n    ) {\n      var fields = this.permissionsMap[operation];\n\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function (operation\n    /*: string*/\n    )\n    /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setReadUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getReadUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setWriteUserFields\",\n    value: function (pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getWriteUserFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n\n  }, {\n    key: \"setProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    , fields\n    /*: string[]*/\n    ) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getProtectedFields\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('find', userId, allowed);\n\n      this._setAccess('get', userId, allowed);\n\n      this._setAccess('count', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('create', userId, allowed);\n\n      this._setAccess('update', userId, allowed);\n\n      this._setAccess('delete', userId, allowed);\n\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function (fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function ()\n    /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function (role\n    /*: ParseRole | string*/\n    , fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\n\nvar _default = ParseCLP;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}