{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n *\n * @alias Parse.Polygon\n */\n\n\nvar ParsePolygon = /*#__PURE__*/function () {\n  /**\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  function ParsePolygon(coordinates\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParsePolygon);\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   *\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\n   * @returns {number[][]}\n   */\n\n\n  (0, _createClass2.default)(ParsePolygon, [{\n    key: \"coordinates\",\n    get: function ()\n    /*: Array<Array<number>>*/\n    {\n      return this._coordinates;\n    },\n    set: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    ) {\n      this._coordinates = ParsePolygon._validate(coords);\n    }\n    /**\n     * Returns a JSON representation of the Polygon, suitable for Parse.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __type: string, coordinates: Array<Array<number>> }*/\n    {\n      ParsePolygon._validate(this._coordinates);\n\n      return {\n        __type: 'Polygon',\n        coordinates: this._coordinates\n      };\n    }\n    /**\n     * Checks if two polygons are equal\n     *\n     * @param {(Parse.Polygon | object)} other\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n        return false;\n      }\n\n      var isEqual = true;\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        if (this._coordinates[i][0] !== other.coordinates[i][0] || this._coordinates[i][1] !== other.coordinates[i][1]) {\n          isEqual = false;\n          break;\n        }\n      }\n\n      return isEqual;\n    }\n    /**\n     *\n     * @param {Parse.GeoPoint} point\n     * @returns {boolean} Returns if the point is contained in the polygon\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function (point\n    /*: ParseGeoPoint*/\n    )\n    /*: boolean*/\n    {\n      var minX = this._coordinates[0][0];\n      var maxX = this._coordinates[0][0];\n      var minY = this._coordinates[0][1];\n      var maxY = this._coordinates[0][1];\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        var p = this._coordinates[i];\n        minX = Math.min(p[0], minX);\n        maxX = Math.max(p[0], maxX);\n        minY = Math.min(p[1], minY);\n        maxY = Math.max(p[1], maxY);\n      }\n\n      var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n\n      if (outside) {\n        return false;\n      }\n\n      var inside = false;\n\n      for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {\n        var startX = this._coordinates[_i][0];\n        var startY = this._coordinates[_i][1];\n        var endX = this._coordinates[j][0];\n        var endY = this._coordinates[j][1];\n        var intersect = startY > point.longitude !== endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n\n      return inside;\n    }\n    /**\n     * Validates that the list of coordinates can form a valid polygon\n     *\n     * @param {Array} coords the list of coordinates to validate as a polygon\n     * @throws {TypeError}\n     * @returns {number[][]} Array of coordinates if validated.\n     */\n\n  }], [{\n    key: \"_validate\",\n    value: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    )\n    /*: Array<Array<number>>*/\n    {\n      if (!(0, _isArray.default)(coords)) {\n        throw new TypeError('Coordinates must be an Array');\n      }\n\n      if (coords.length < 3) {\n        throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n      }\n\n      var points = [];\n\n      for (var i = 0; i < coords.length; i += 1) {\n        var coord = coords[i];\n        var geoPoint = void 0;\n\n        if (coord instanceof _ParseGeoPoint.default) {\n          geoPoint = coord;\n        } else if ((0, _isArray.default)(coord) && coord.length === 2) {\n          geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n        } else {\n          throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n        }\n\n        points.push([geoPoint.latitude, geoPoint.longitude]);\n      }\n\n      return points;\n    }\n  }]);\n  return ParsePolygon;\n}();\n\nvar _default = ParsePolygon;\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/Twitter-Start/node_modules/moralis/lib/browser/ParsePolygon.js"],"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_isArray","_classCallCheck2","_createClass2","_defineProperty2","_ParseGeoPoint","ParsePolygon","coordinates","_coordinates","_validate","key","get","set","coords","__type","other","length","isEqual","i","point","minX","maxX","minY","maxY","p","Math","min","max","outside","latitude","longitude","inside","_i","j","startX","startY","endX","endY","intersect","TypeError","points","coord","geoPoint","push","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8DAAD,CAApC;;AAEA,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,sDAAD,CAApC;;AAEAD,sBAAsB,CAACG,OAAD,EAAU,YAAV,EAAwB;AAC5CC,EAAAA,KAAK,EAAE;AADqC,CAAxB,CAAtB;;AAIAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,QAAQ,GAAGJ,sBAAsB,CAACD,OAAO,CAAC,sDAAD,CAAR,CAArC;;AAEA,IAAIM,gBAAgB,GAAGL,sBAAsB,CAACD,OAAO,CAAC,+CAAD,CAAR,CAA7C;;AAEA,IAAIO,aAAa,GAAGN,sBAAsB,CAACD,OAAO,CAAC,4CAAD,CAAR,CAA1C;;AAEA,IAAIQ,gBAAgB,GAAGP,sBAAsB,CAACD,OAAO,CAAC,+CAAD,CAAR,CAA7C;;AAEA,IAAIS,cAAc,GAAGR,sBAAsB,CAACD,OAAO,CAAC,iBAAD,CAAR,CAA3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAIU,YAAY,GAAG,aAAa,YAAY;AAC1C;AACF;AACA;AACE,WAASA,YAAT,CAAsBC;AACtB;AADA,IAEE;AACA,KAAC,GAAGL,gBAAgB,CAACF,OAArB,EAA8B,IAA9B,EAAoCM,YAApC;AACA,KAAC,GAAGF,gBAAgB,CAACJ,OAArB,EAA8B,IAA9B,EAAoC,cAApC,EAAoD,KAAK,CAAzD;AACA,SAAKQ,YAAL,GAAoBF,YAAY,CAACG,SAAb,CAAuBF,WAAvB,CAApB;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGE,GAAC,GAAGJ,aAAa,CAACH,OAAlB,EAA2BM,YAA3B,EAAyC,CAAC;AACxCI,IAAAA,GAAG,EAAE,aADmC;AAExCC,IAAAA,GAAG,EAAE;AACL;AACA;AACE,aAAO,KAAKH,YAAZ;AACD,KANuC;AAOxCI,IAAAA,GAAG,EAAE,UAAUC;AACf;AADK,MAEH;AACA,WAAKL,YAAL,GAAoBF,YAAY,CAACG,SAAb,CAAuBI,MAAvB,CAApB;AACD;AACD;AACJ;AACA;AACA;AACA;;AAhB4C,GAAD,EAkBtC;AACDH,IAAAA,GAAG,EAAE,QADJ;AAEDX,IAAAA,KAAK,EAAE;AACP;AACA;AACEO,MAAAA,YAAY,CAACG,SAAb,CAAuB,KAAKD,YAA5B;;AAEA,aAAO;AACLM,QAAAA,MAAM,EAAE,SADH;AAELP,QAAAA,WAAW,EAAE,KAAKC;AAFb,OAAP;AAID;AACD;AACJ;AACA;AACA;AACA;AACA;;AAjBK,GAlBsC,EAqCtC;AACDE,IAAAA,GAAG,EAAE,QADJ;AAEDX,IAAAA,KAAK,EAAE,UAAUgB;AACjB;AADO;AAGP;AACA;AACE,UAAI,EAAEA,KAAK,YAAYT,YAAnB,KAAoC,KAAKC,WAAL,CAAiBS,MAAjB,KAA4BD,KAAK,CAACR,WAAN,CAAkBS,MAAtF,EAA8F;AAC5F,eAAO,KAAP;AACD;;AAED,UAAIC,OAAO,GAAG,IAAd;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,YAAL,CAAkBQ,MAAtC,EAA8CE,CAAC,IAAI,CAAnD,EAAsD;AACpD,YAAI,KAAKV,YAAL,CAAkBU,CAAlB,EAAqB,CAArB,MAA4BH,KAAK,CAACR,WAAN,CAAkBW,CAAlB,EAAqB,CAArB,CAA5B,IAAuD,KAAKV,YAAL,CAAkBU,CAAlB,EAAqB,CAArB,MAA4BH,KAAK,CAACR,WAAN,CAAkBW,CAAlB,EAAqB,CAArB,CAAvF,EAAgH;AAC9GD,UAAAA,OAAO,GAAG,KAAV;AACA;AACD;AACF;;AAED,aAAOA,OAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;AA1BK,GArCsC,EAiEtC;AACDP,IAAAA,GAAG,EAAE,eADJ;AAEDX,IAAAA,KAAK,EAAE,UAAUoB;AACjB;AADO;AAGP;AACA;AACE,UAAIC,IAAI,GAAG,KAAKZ,YAAL,CAAkB,CAAlB,EAAqB,CAArB,CAAX;AACA,UAAIa,IAAI,GAAG,KAAKb,YAAL,CAAkB,CAAlB,EAAqB,CAArB,CAAX;AACA,UAAIc,IAAI,GAAG,KAAKd,YAAL,CAAkB,CAAlB,EAAqB,CAArB,CAAX;AACA,UAAIe,IAAI,GAAG,KAAKf,YAAL,CAAkB,CAAlB,EAAqB,CAArB,CAAX;;AAEA,WAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,YAAL,CAAkBQ,MAAtC,EAA8CE,CAAC,IAAI,CAAnD,EAAsD;AACpD,YAAIM,CAAC,GAAG,KAAKhB,YAAL,CAAkBU,CAAlB,CAAR;AACAE,QAAAA,IAAI,GAAGK,IAAI,CAACC,GAAL,CAASF,CAAC,CAAC,CAAD,CAAV,EAAeJ,IAAf,CAAP;AACAC,QAAAA,IAAI,GAAGI,IAAI,CAACE,GAAL,CAASH,CAAC,CAAC,CAAD,CAAV,EAAeH,IAAf,CAAP;AACAC,QAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,CAASF,CAAC,CAAC,CAAD,CAAV,EAAeF,IAAf,CAAP;AACAC,QAAAA,IAAI,GAAGE,IAAI,CAACE,GAAL,CAASH,CAAC,CAAC,CAAD,CAAV,EAAeD,IAAf,CAAP;AACD;;AAED,UAAIK,OAAO,GAAGT,KAAK,CAACU,QAAN,GAAiBT,IAAjB,IAAyBD,KAAK,CAACU,QAAN,GAAiBR,IAA1C,IAAkDF,KAAK,CAACW,SAAN,GAAkBR,IAApE,IAA4EH,KAAK,CAACW,SAAN,GAAkBP,IAA5G;;AAEA,UAAIK,OAAJ,EAAa;AACX,eAAO,KAAP;AACD;;AAED,UAAIG,MAAM,GAAG,KAAb;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAT,EAAYC,CAAC,GAAG,KAAKzB,YAAL,CAAkBQ,MAAlB,GAA2B,CAAhD,EAAmDgB,EAAE,GAAG,KAAKxB,YAAL,CAAkBQ,MAA1E,EAAkFiB,CAAC,GAAGD,EAAE,EAAxF,EAA4F;AAC1F,YAAIE,MAAM,GAAG,KAAK1B,YAAL,CAAkBwB,EAAlB,EAAsB,CAAtB,CAAb;AACA,YAAIG,MAAM,GAAG,KAAK3B,YAAL,CAAkBwB,EAAlB,EAAsB,CAAtB,CAAb;AACA,YAAII,IAAI,GAAG,KAAK5B,YAAL,CAAkByB,CAAlB,EAAqB,CAArB,CAAX;AACA,YAAII,IAAI,GAAG,KAAK7B,YAAL,CAAkByB,CAAlB,EAAqB,CAArB,CAAX;AACA,YAAIK,SAAS,GAAGH,MAAM,GAAGhB,KAAK,CAACW,SAAf,KAA6BO,IAAI,GAAGlB,KAAK,CAACW,SAA1C,IAAuDX,KAAK,CAACU,QAAN,GAAiB,CAACO,IAAI,GAAGF,MAAR,KAAmBf,KAAK,CAACW,SAAN,GAAkBK,MAArC,KAAgDE,IAAI,GAAGF,MAAvD,IAAiED,MAAzJ;;AAEA,YAAII,SAAJ,EAAe;AACbP,UAAAA,MAAM,GAAG,CAACA,MAAV;AACD;AACF;;AAED,aAAOA,MAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAhDK,GAjEsC,CAAzC,EAmHI,CAAC;AACHrB,IAAAA,GAAG,EAAE,WADF;AAEHX,IAAAA,KAAK,EAAE,UAAUc;AACjB;AADO;AAGP;AACA;AACE,UAAI,CAAC,CAAC,GAAGZ,QAAQ,CAACD,OAAb,EAAsBa,MAAtB,CAAL,EAAoC;AAClC,cAAM,IAAI0B,SAAJ,CAAc,8BAAd,CAAN;AACD;;AAED,UAAI1B,MAAM,CAACG,MAAP,GAAgB,CAApB,EAAuB;AACrB,cAAM,IAAIuB,SAAJ,CAAc,kDAAd,CAAN;AACD;;AAED,UAAIC,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACG,MAA3B,EAAmCE,CAAC,IAAI,CAAxC,EAA2C;AACzC,YAAIuB,KAAK,GAAG5B,MAAM,CAACK,CAAD,CAAlB;AACA,YAAIwB,QAAQ,GAAG,KAAK,CAApB;;AAEA,YAAID,KAAK,YAAYpC,cAAc,CAACL,OAApC,EAA6C;AAC3C0C,UAAAA,QAAQ,GAAGD,KAAX;AACD,SAFD,MAEO,IAAI,CAAC,GAAGxC,QAAQ,CAACD,OAAb,EAAsByC,KAAtB,KAAgCA,KAAK,CAACzB,MAAN,KAAiB,CAArD,EAAwD;AAC7D0B,UAAAA,QAAQ,GAAG,IAAIrC,cAAc,CAACL,OAAnB,CAA2ByC,KAAK,CAAC,CAAD,CAAhC,EAAqCA,KAAK,CAAC,CAAD,CAA1C,CAAX;AACD,SAFM,MAEA;AACL,gBAAM,IAAIF,SAAJ,CAAc,qDAAd,CAAN;AACD;;AAEDC,QAAAA,MAAM,CAACG,IAAP,CAAY,CAACD,QAAQ,CAACb,QAAV,EAAoBa,QAAQ,CAACZ,SAA7B,CAAZ;AACD;;AAED,aAAOU,MAAP;AACD;AAjCE,GAAD,CAnHJ;AAsJA,SAAOlC,YAAP;AACD,CA3K+B,EAAhC;;AA6KA,IAAIsC,QAAQ,GAAGtC,YAAf;AACAR,OAAO,CAACE,OAAR,GAAkB4C,QAAlB","sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n *\n * @alias Parse.Polygon\n */\n\n\nvar ParsePolygon = /*#__PURE__*/function () {\n  /**\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  function ParsePolygon(coordinates\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParsePolygon);\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   *\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\n   * @returns {number[][]}\n   */\n\n\n  (0, _createClass2.default)(ParsePolygon, [{\n    key: \"coordinates\",\n    get: function ()\n    /*: Array<Array<number>>*/\n    {\n      return this._coordinates;\n    },\n    set: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    ) {\n      this._coordinates = ParsePolygon._validate(coords);\n    }\n    /**\n     * Returns a JSON representation of the Polygon, suitable for Parse.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __type: string, coordinates: Array<Array<number>> }*/\n    {\n      ParsePolygon._validate(this._coordinates);\n\n      return {\n        __type: 'Polygon',\n        coordinates: this._coordinates\n      };\n    }\n    /**\n     * Checks if two polygons are equal\n     *\n     * @param {(Parse.Polygon | object)} other\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n        return false;\n      }\n\n      var isEqual = true;\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        if (this._coordinates[i][0] !== other.coordinates[i][0] || this._coordinates[i][1] !== other.coordinates[i][1]) {\n          isEqual = false;\n          break;\n        }\n      }\n\n      return isEqual;\n    }\n    /**\n     *\n     * @param {Parse.GeoPoint} point\n     * @returns {boolean} Returns if the point is contained in the polygon\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function (point\n    /*: ParseGeoPoint*/\n    )\n    /*: boolean*/\n    {\n      var minX = this._coordinates[0][0];\n      var maxX = this._coordinates[0][0];\n      var minY = this._coordinates[0][1];\n      var maxY = this._coordinates[0][1];\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        var p = this._coordinates[i];\n        minX = Math.min(p[0], minX);\n        maxX = Math.max(p[0], maxX);\n        minY = Math.min(p[1], minY);\n        maxY = Math.max(p[1], maxY);\n      }\n\n      var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n\n      if (outside) {\n        return false;\n      }\n\n      var inside = false;\n\n      for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {\n        var startX = this._coordinates[_i][0];\n        var startY = this._coordinates[_i][1];\n        var endX = this._coordinates[j][0];\n        var endY = this._coordinates[j][1];\n        var intersect = startY > point.longitude !== endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n\n      return inside;\n    }\n    /**\n     * Validates that the list of coordinates can form a valid polygon\n     *\n     * @param {Array} coords the list of coordinates to validate as a polygon\n     * @throws {TypeError}\n     * @returns {number[][]} Array of coordinates if validated.\n     */\n\n  }], [{\n    key: \"_validate\",\n    value: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    )\n    /*: Array<Array<number>>*/\n    {\n      if (!(0, _isArray.default)(coords)) {\n        throw new TypeError('Coordinates must be an Array');\n      }\n\n      if (coords.length < 3) {\n        throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n      }\n\n      var points = [];\n\n      for (var i = 0; i < coords.length; i += 1) {\n        var coord = coords[i];\n        var geoPoint = void 0;\n\n        if (coord instanceof _ParseGeoPoint.default) {\n          geoPoint = coord;\n        } else if ((0, _isArray.default)(coord) && coord.length === 2) {\n          geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n        } else {\n          throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n        }\n\n        points.push([geoPoint.latitude, geoPoint.longitude]);\n      }\n\n      return points;\n    }\n  }]);\n  return ParsePolygon;\n}();\n\nvar _default = ParsePolygon;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}