{"version":3,"sources":["webpack://TorusUtils/webpack/bootstrap","webpack://TorusUtils/external \"@babel/runtime/regenerator\"","webpack://TorusUtils/external \"bn.js\"","webpack://TorusUtils/external \"@toruslabs/http-helpers\"","webpack://TorusUtils/external \"@babel/runtime/helpers/asyncToGenerator\"","webpack://TorusUtils/external \"web3-utils\"","webpack://TorusUtils/external \"@babel/runtime/helpers/classCallCheck\"","webpack://TorusUtils/external \"@babel/runtime/helpers/createClass\"","webpack://TorusUtils/external \"@babel/runtime/helpers/getPrototypeOf\"","webpack://TorusUtils/external \"@toruslabs/eccrypto\"","webpack://TorusUtils/external \"@babel/runtime/helpers/defineProperty\"","webpack://TorusUtils/external \"json-stable-stringify\"","webpack://TorusUtils/external \"@babel/runtime/helpers/inherits\"","webpack://TorusUtils/external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://TorusUtils/external \"@babel/runtime/helpers/wrapNativeSuper\"","webpack://TorusUtils/external \"@babel/runtime/helpers/toConsumableArray\"","webpack://TorusUtils/external \"@babel/runtime/helpers/typeof\"","webpack://TorusUtils/external \"elliptic\"","webpack://TorusUtils/external \"loglevel\"","webpack://TorusUtils/./src/loglevel.js","webpack://TorusUtils/./src/some.js","webpack://TorusUtils/./src/utils.js","webpack://TorusUtils/./src/torus.js","webpack://TorusUtils/./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","log","loglevel","getLogger","disableAll","SomeError","errors","responses","predicate","Error","Some","promises","Promise","resolve","reject","predicateError","finishedCount","sharedState","resolved","errorArr","Array","length","fill","undefined","resultArr","forEach","x","index","then","resp","catch","error","finally","slice","data","_","values","reduce","acc","z","str","id","startsWith","charAt","toUpperCase","msg","map","it","join","message","GetOrSetNonceError","kCombinations","k","set","from","cur","combs","tailCombs","j","push","thresholdSame","arr","hashMap","JsonStringify","keyLookup","endpoints","verifier","verifierId","a","lookupPromises","post","generateJsonRPCObject","verifier_id","toString","err","lookupResults","lookupShares","filter","x1","errorResult","x2","keyResult","x3","result","JSON","stringify","waitKeyLookup","timeout","setTimeout","keyAssign","torusNodePubs","lastPoint","firstPoint","signerHost","network","nodeNum","Math","floor","random","initialPoint","headers","pubKeyX","X","pubKeyY","Y","useAPIKey","signedData","includes","Torus","enableOneKey","metadataHost","allowHost","serverTimeOffset","this","ec","EC","doesKeyAssign","isNewKey","assignResult","finalKeyResult","keys","pub_key_X","pub_key_Y","getOrSetNonce","typeOfUser","nonce","pubNonce","upgraded","BN","modifiedPubKey","keyFromPublic","y","getPublic","add","keyFromPrivate","finalX","getX","finalY","getY","address","generateAddressFromPubKey","privKeyHex","metadataNonce","torusKeyHex","customKeyHex","torusKey","privKey","sub","umod","curve","customKey","newMetadataNonce","generateMetadataParams","setMetadata","indexes","verifierParams","idToken","extraParams","promiseArr","tmpKey","generatePrivate","pubKey","tokenCommitment","keccak256","messageprefix","tokencommitment","temppubx","temppuby","verifieridentifier","promiseArrRequest","nodeSigs","encrypted","item","idtoken","nodesignatures","shareResponses","completedRequests","thresholdPublicKey","PublicKey","sharePromises","nodeIndex","sort","b","Index","cmp","Metadata","metadata","ephemPublicKey","Buffer","iv","mac","decrypt","ciphertext","atob","Share","padStart","debug","all","sharesResolved","decryptedShares","curr","allCombis","currentCombi","currentCombiShares","v","shares","indices","derivedPrivateKey","lagrangeInterpolation","decryptedPubKey","decryptedPubKeyX","decryptedPubKeyY","privateKey","returnedKey","getNonce","getMetadata","ethAddress","generateAddressFromPrivKey","options","metadataResponse","setData","timestamp","Date","now","sig","sign","set_data","signature","secret","upper","lower","mul","neg","temp","delta","invm","publicKey","encode","ethAddressLower","toChecksumAddress","publicKeyX","publicKeyY","isExtended","getOnly","privKeyBN","nonceBN","enableAll","apiKey","setAPIKey","embedHost","setEmbedHost"],"mappings":"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","file":"torusUtils.cjs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","module.exports = require(\"@babel/runtime/regenerator\");","module.exports = require(\"bn.js\");","module.exports = require(\"@toruslabs/http-helpers\");","module.exports = require(\"@babel/runtime/helpers/asyncToGenerator\");","module.exports = require(\"web3-utils\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@toruslabs/eccrypto\");","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"json-stable-stringify\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/wrapNativeSuper\");","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","module.exports = require(\"@babel/runtime/helpers/typeof\");","module.exports = require(\"elliptic\");","module.exports = require(\"loglevel\");","import loglevel from 'loglevel'\n\nconst log = loglevel.getLogger('torus.js')\nlog.disableAll()\n\nexport default log\n","function capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport class SomeError extends Error {\n  constructor({ errors, responses, predicate }) {\n    super('Unable to resolve enough promises.')\n    this.errors = errors\n    this.responses = responses\n    this.predicate = predicate\n  }\n}\n\nexport const Some = (promises, predicate) =>\n  new Promise((resolve, reject) => {\n    let finishedCount = 0\n    const sharedState = { resolved: false }\n    const errorArr = new Array(promises.length).fill(undefined)\n    const resultArr = new Array(promises.length).fill(undefined)\n    let predicateError\n    promises.forEach((x, index) => {\n      x.then((resp) => {\n        resultArr[index] = resp\n        return undefined\n      })\n        .catch((error) => {\n          errorArr[index] = error\n        })\n        .finally(() => {\n          if (sharedState.resolved) return\n          predicate(resultArr.slice(0), sharedState)\n            .then((data) => {\n              sharedState.resolved = true\n              resolve(data)\n              return undefined\n            })\n            .catch((error) => {\n              // log only the last predicate error\n              predicateError = error\n            })\n            .finally((_) => {\n              finishedCount += 1\n              if (finishedCount === promises.length) {\n                const errors = Object.values(\n                  resultArr.reduce((acc, z) => {\n                    const { id, error } = z || {}\n                    if (error?.data?.length > 0) {\n                      if (error.data.startsWith('Error occurred while verifying params')) acc[id] = capitalizeFirstLetter(error.data)\n                      else acc[id] = error.data\n                    }\n                    return acc\n                  }, {})\n                )\n\n                if (errors.length > 0) {\n                  // Format-able errors\n                  const msg = errors.length > 1 ? `\\n${errors.map((it) => `â€¢ ${it}`).join('\\n')}` : errors[0]\n                  reject(new Error(msg))\n                } else {\n                  reject(\n                    new SomeError({\n                      errors: errorArr,\n                      responses: resultArr,\n                      predicate: predicateError?.message || predicateError,\n                    })\n                  )\n                }\n              }\n            })\n        })\n    })\n  })\n","import { generateJsonRPCObject, post } from '@toruslabs/http-helpers'\nimport JsonStringify from 'json-stable-stringify'\n\nimport log from './loglevel'\nimport { Some } from './some'\n\nexport class GetOrSetNonceError extends Error {}\n\nexport const kCombinations = (s, k) => {\n  let set = s\n  if (typeof set === 'number') {\n    set = Array.from({ length: set }, (_, i) => i)\n  }\n  if (k > set.length || k <= 0) {\n    return []\n  }\n\n  if (k === set.length) {\n    return [set]\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], [])\n  }\n\n  const combs = []\n  let tailCombs = []\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1)\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]])\n    }\n  }\n\n  return combs\n}\n\nexport const thresholdSame = (arr, t) => {\n  const hashMap = {}\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i])\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1\n    if (hashMap[str] === t) {\n      return arr[i]\n    }\n  }\n  return undefined\n}\n\nexport const keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map((x) =>\n    post(\n      x,\n      generateJsonRPCObject('VerifierLookupRequest', {\n        verifier,\n        verifier_id: verifierId.toString(),\n      })\n    ).catch((err) => log.error('lookup request failed', err))\n  )\n  return Some(lookupPromises, (lookupResults) => {\n    const lookupShares = lookupResults.filter((x1) => x1)\n    const errorResult = thresholdSame(\n      lookupShares.map((x2) => x2 && x2.error),\n      ~~(endpoints.length / 2) + 1\n    )\n    const keyResult = thresholdSame(\n      lookupShares.map((x3) => x3 && x3.result),\n      ~~(endpoints.length / 2) + 1\n    )\n    if (keyResult || errorResult) {\n      return Promise.resolve({ keyResult, errorResult })\n    }\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`))\n  })\n}\n\nexport const waitKeyLookup = (endpoints, verifier, verifierId, timeout) =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject)\n    }, timeout)\n  })\n\nexport const keyAssign = async ({ endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost, network }) => {\n  let nodeNum\n  let initialPoint\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length)\n    initialPoint = nodeNum\n  } else {\n    nodeNum = lastPoint % endpoints.length\n  }\n  if (nodeNum === firstPoint) throw new Error('Looped through all')\n  if (firstPoint !== undefined) initialPoint = firstPoint\n\n  const data = generateJsonRPCObject('KeyAssign', {\n    verifier,\n    verifier_id: verifierId.toString(),\n  })\n  try {\n    const signedData = await post(\n      signerHost,\n      data,\n      {\n        headers: {\n          pubKeyX: torusNodePubs[nodeNum].X,\n          pubKeyY: torusNodePubs[nodeNum].Y,\n          network,\n        },\n      },\n      { useAPIKey: true }\n    )\n    return post(\n      endpoints[nodeNum],\n      { ...data, ...signedData },\n      {\n        headers: {\n          'Content-Type': 'application/json; charset=utf-8',\n        },\n      }\n    )\n  } catch (error) {\n    log.error(error)\n    const acceptedErrorMsgs = [\n      // Slow node\n      'Timed out',\n      // Happens when the node is not reachable (dns issue etc)\n      'TypeError: Failed to fetch', // All except iOS and Firefox\n      'TypeError: cancelled', // iOS\n      'TypeError: NetworkError when attempting to fetch resource.', // Firefox\n    ]\n    if (acceptedErrorMsgs.includes(error.message))\n      return keyAssign({ endpoints, torusNodePubs, lastPoint: nodeNum + 1, firstPoint: initialPoint, verifier, verifierId, signerHost, network })\n    throw new Error(\n      `Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || ''}`\n    )\n  }\n}\n","import { decrypt, generatePrivate, getPublic } from '@toruslabs/eccrypto'\nimport { generateJsonRPCObject, get, post, setAPIKey, setEmbedHost } from '@toruslabs/http-helpers'\nimport BN from 'bn.js'\nimport { ec as EC } from 'elliptic'\nimport stringify from 'json-stable-stringify'\nimport { keccak256, toChecksumAddress } from 'web3-utils'\n\nimport log from './loglevel'\nimport { Some } from './some'\nimport { GetOrSetNonceError, kCombinations, keyAssign, keyLookup, thresholdSame, waitKeyLookup } from './utils'\n\n// Implement threshold logic wrappers around public APIs\n// of Torus nodes to handle malicious node responses\nclass Torus {\n  constructor({\n    enableOneKey = false,\n    metadataHost = 'https://metadata.tor.us',\n    allowHost = 'https://signer.tor.us/api/allow',\n    signerHost = 'https://signer.tor.us/api/sign',\n    serverTimeOffset = 0,\n    network = 'mainnet',\n  } = {}) {\n    this.ec = new EC('secp256k1')\n    this.metadataHost = metadataHost\n    this.allowHost = allowHost\n    this.enableOneKey = enableOneKey\n    this.serverTimeOffset = serverTimeOffset || 0 // ms\n    this.signerHost = signerHost\n    this.network = network\n  }\n\n  static enableLogging(v = true) {\n    if (v) log.enableAll()\n    else log.disableAll()\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey)\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost)\n  }\n\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n  async getUserTypeAndAddress(endpoints, torusNodePubs, { verifier, verifierId }, doesKeyAssign = false) {\n    const { keyResult, errorResult } = (await keyLookup(endpoints, verifier, verifierId)) || {}\n    let isNewKey = false\n    let finalKeyResult\n    if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {\n      if (!doesKeyAssign) {\n        throw new Error('Verifier + VerifierID has not yet been assigned')\n      }\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network,\n      })\n      const assignResult = (await waitKeyLookup(endpoints, verifier, verifierId, 1000)) || {}\n      finalKeyResult = assignResult.keyResult\n      isNewKey = true\n    } else if (keyResult) {\n      finalKeyResult = keyResult\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n    }\n    if (finalKeyResult) {\n      const { pub_key_X: X, pub_key_Y: Y } = finalKeyResult.keys[0]\n      let typeOfUser\n      let nonce\n      let pubNonce\n      let modifiedPubKey\n      let upgraded\n\n      try {\n        ;({ typeOfUser, nonce, pubNonce, upgraded } = await this.getOrSetNonce(X, Y, undefined, !isNewKey))\n        nonce = new BN(nonce || '0', 16)\n      } catch {\n        throw new GetOrSetNonceError()\n      }\n      if (typeOfUser === 'v1') {\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n      } else if (typeOfUser === 'v2') {\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPublic({ x: pubNonce.x, y: pubNonce.y }).getPublic())\n      } else {\n        throw new Error('getOrSetNonce should always return typeOfUser.')\n      }\n      const finalX = modifiedPubKey.getX().toString(16)\n      const finalY = modifiedPubKey.getY().toString(16)\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY())\n      return { typeOfUser, nonce, pubNonce, upgraded, X: finalX, Y: finalY, address }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n  }\n\n  async setCustomKey({ privKeyHex, metadataNonce, torusKeyHex, customKeyHex }) {\n    let torusKey\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16)\n    } else {\n      const privKey = new BN(privKeyHex, 16)\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n)\n    }\n    const customKey = new BN(customKeyHex, 16)\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n)\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey.toString(16))\n    await this.setMetadata(data)\n  }\n\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken, extraParams = {}) {\n    const promiseArr = []\n    await get(\n      this.allowHost,\n      {\n        headers: {\n          verifier,\n          verifier_id: verifierParams.verifier_id,\n          network: this.network,\n        },\n      },\n      { useAPIKey: true }\n    )\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      } \n      */\n\n    // generate temporary private and public key that is used to secure receive shares\n    const tmpKey = generatePrivate()\n    const pubKey = getPublic(tmpKey).toString('hex')\n    const pubKeyX = pubKey.slice(2, 66)\n    const pubKeyY = pubKey.slice(66)\n    const tokenCommitment = keccak256(idToken)\n\n    // make commitment requests to endpoints\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(\n        endpoints[i],\n        generateJsonRPCObject('CommitmentRequest', {\n          messageprefix: 'mug00',\n          tokencommitment: tokenCommitment.slice(2),\n          temppubx: pubKeyX,\n          temppuby: pubKeyY,\n          verifieridentifier: verifier,\n        })\n      ).catch((err) => log.error('commitment', err))\n      promiseArr.push(p)\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n    return Some(promiseArr, (resultArr) => {\n      const completedRequests = resultArr.filter((x) => {\n        if (!x || typeof x !== 'object') {\n          return false\n        }\n        if (x.error) {\n          return false\n        }\n        return true\n      })\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr)\n      }\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`))\n    })\n      .then((responses) => {\n        const promiseArrRequest = []\n        const nodeSigs = []\n        for (let i = 0; i < responses.length; i += 1) {\n          if (responses[i]) nodeSigs.push(responses[i].result)\n        }\n        for (let i = 0; i < endpoints.length; i += 1) {\n          // eslint-disable-next-line promise/no-nesting\n          const p = post(\n            endpoints[i],\n            generateJsonRPCObject('ShareRequest', {\n              encrypted: 'yes',\n              item: [{ ...verifierParams, idtoken: idToken, nodesignatures: nodeSigs, verifieridentifier: verifier, ...extraParams }],\n            })\n          ).catch((err) => log.error('share req', err))\n          promiseArrRequest.push(p)\n        }\n        return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n          /*\n              ShareRequestResult struct {\n                Keys []KeyAssignment\n              }\n                      / KeyAssignmentPublic -\n              type KeyAssignmentPublic struct {\n                Index     big.Int\n                PublicKey common.Point\n                Threshold int\n                Verifiers map[string][]string // Verifier => VerifierID\n              }\n\n              // KeyAssignment -\n              type KeyAssignment struct {\n                KeyAssignmentPublic\n                Share big.Int // Or Si\n              }\n            */\n          // check if threshold number of nodes have returned the same user public key\n          const completedRequests = shareResponses.filter((x) => x)\n          const thresholdPublicKey = thresholdSame(\n            shareResponses.map((x) => x && x.result && x.result.keys[0].PublicKey),\n            ~~(endpoints.length / 2) + 1\n          )\n          // optimistically run lagrange interpolation once threshold number of shares have been received\n          // this is matched against the user public key to ensure that shares are consistent\n          if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n            const sharePromises = []\n            const nodeIndex = []\n            for (let i = 0; i < shareResponses.length; i += 1) {\n              if (shareResponses[i] && shareResponses[i].result && shareResponses[i].result.keys && shareResponses[i].result.keys.length > 0) {\n                shareResponses[i].result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)))\n                if (shareResponses[i].result.keys[0].Metadata) {\n                  const metadata = {\n                    ephemPublicKey: Buffer.from(shareResponses[i].result.keys[0].Metadata.ephemPublicKey, 'hex'),\n                    iv: Buffer.from(shareResponses[i].result.keys[0].Metadata.iv, 'hex'),\n                    mac: Buffer.from(shareResponses[i].result.keys[0].Metadata.mac, 'hex'),\n                    mode: Buffer.from(shareResponses[i].result.keys[0].Metadata.mode, 'hex'),\n                  }\n                  sharePromises.push(\n                    // eslint-disable-next-line promise/no-nesting\n                    decrypt(tmpKey, {\n                      ...metadata,\n                      ciphertext: Buffer.from(atob(shareResponses[i].result.keys[0].Share).padStart(64, '0'), 'hex'),\n                    }).catch((err) => log.debug('share decryption', err))\n                  )\n                } else {\n                  sharePromises.push(Promise.resolve(Buffer.from(shareResponses[i].result.keys[0].Share.padStart(64, '0'), 'hex')))\n                }\n              } else {\n                sharePromises.push(Promise.resolve(undefined))\n              }\n              nodeIndex.push(new BN(indexes[i], 16))\n            }\n            const sharesResolved = await Promise.all(sharePromises)\n            if (sharedState.resolved) return undefined\n\n            const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n              if (curr) acc.push({ index: nodeIndex[index], value: new BN(curr) })\n              return acc\n            }, [])\n            // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n            const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1)\n            let privateKey\n            for (let j = 0; j < allCombis.length; j += 1) {\n              const currentCombi = allCombis[j]\n              const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index))\n              const shares = currentCombiShares.map((x) => x.value)\n              const indices = currentCombiShares.map((x) => x.index)\n              const derivedPrivateKey = this.lagrangeInterpolation(shares, indices)\n              const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex')\n              const decryptedPubKeyX = decryptedPubKey.slice(2, 66)\n              const decryptedPubKeyY = decryptedPubKey.slice(66)\n              if (\n                new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 &&\n                new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0\n              ) {\n                privateKey = derivedPrivateKey\n                break\n              }\n            }\n            if (privateKey === undefined) {\n              throw new Error('could not derive private key')\n            }\n            return privateKey\n          }\n          throw new Error('invalid')\n        })\n      })\n      .then(async (returnedKey) => {\n        let privateKey = returnedKey\n        const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), 'hex')).toString('hex')\n        const decryptedPubKeyX = decryptedPubKey.slice(2, 66)\n        const decryptedPubKeyY = decryptedPubKey.slice(66)\n        let metadataNonce\n        if (this.enableOneKey) {\n          const { nonce } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey)\n          metadataNonce = new BN(nonce || '0', 16)\n        } else {\n          metadataNonce = await this.getMetadata({ pub_key_X: decryptedPubKeyX, pub_key_Y: decryptedPubKeyY })\n        }\n        log.debug('> torus.js/retrieveShares', { privKey: privateKey.toString(16), metadataNonce: metadataNonce.toString(16) })\n\n        privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n)\n\n        const ethAddress = this.generateAddressFromPrivKey(privateKey)\n        log.debug('> torus.js/retrieveShares', { ethAddress, privKey: privateKey.toString(16) })\n\n        // return reconstructed private key and ethereum address\n        return {\n          ethAddress,\n          privKey: privateKey.toString('hex', 64),\n          metadataNonce,\n        }\n      })\n  }\n\n  async getMetadata(data, options) {\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, { useAPIKey: true })\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0)\n      }\n      return new BN(metadataResponse.message, 16) // nonce\n    } catch (error) {\n      log.error('get metadata error', error)\n      return new BN(0)\n    }\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString('hex', 64))\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16),\n    }\n    const sig = key.sign(keccak256(stringify(setData)).slice(2))\n    return {\n      pub_key_X: key.getPublic().getX().toString('hex'),\n      pub_key_Y: key.getPublic().getY().toString('hex'),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(sig.v).toString(16, 2), 'hex').toString('base64'),\n    }\n  }\n\n  async setMetadata(data, options) {\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, { useAPIKey: true })\n      return metadataResponse.message // IPFS hash\n    } catch (error) {\n      log.error('set metadata error', error)\n      return ''\n    }\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null\n    }\n    let secret = new BN(0)\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1)\n      let lower = new BN(1)\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg())\n          upper = upper.umod(this.ec.curve.n)\n          let temp = nodeIndex[i].sub(nodeIndex[j])\n          temp = temp.umod(this.ec.curve.n)\n          lower = lower.mul(temp).umod(this.ec.curve.n)\n        }\n      }\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n)\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n)\n      secret = secret.add(delta)\n    }\n    return secret.umod(this.ec.curve.n)\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex')\n    const publicKey = key.getPublic().encode('hex').slice(2)\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38)}`\n    return toChecksumAddress(ethAddressLower)\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({ x: publicKeyX.toString('hex', 64), y: publicKeyY.toString('hex', 64) })\n    const publicKey = key.getPublic().encode('hex').slice(2)\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38)}`\n    return toChecksumAddress(ethAddressLower)\n  }\n\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n  async getPublicAddress(endpoints, torusNodePubs, { verifier, verifierId }, isExtended = false) {\n    log.debug('> torus.js/getPublicAddress', { endpoints, torusNodePubs, verifier, verifierId, isExtended })\n\n    let finalKeyResult\n    let isNewKey = false\n\n    const { keyResult, errorResult } = (await keyLookup(endpoints, verifier, verifierId)) || {}\n    if (errorResult && JSON.stringify(errorResult).includes('Verifier not supported')) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`)\n    } else if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network,\n      })\n      const assignResult = (await waitKeyLookup(endpoints, verifier, verifierId, 1000)) || {}\n      finalKeyResult = assignResult.keyResult\n      isNewKey = true\n    } else if (keyResult) {\n      finalKeyResult = keyResult\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n    }\n    log.debug('> torus.js/getPublicAddress', { finalKeyResult, isNewKey })\n\n    if (finalKeyResult) {\n      let { pub_key_X: X, pub_key_Y: Y } = finalKeyResult.keys[0]\n      let typeOfUser\n      let nonce\n      let pubNonce\n      let modifiedPubKey\n      if (this.enableOneKey) {\n        let upgraded\n        try {\n          ;({ typeOfUser, nonce, pubNonce, upgraded } = await this.getOrSetNonce(X, Y, undefined, !isNewKey))\n          nonce = new BN(nonce || '0', 16)\n        } catch {\n          throw new GetOrSetNonceError()\n        }\n        if (typeOfUser === 'v1') {\n          modifiedPubKey = this.ec\n            .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n            .getPublic()\n            .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n        } else if (typeOfUser === 'v2') {\n          if (upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({ x: X.toString(16), y: Y.toString(16) }).getPublic()\n          } else {\n            modifiedPubKey = this.ec\n              .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n              .getPublic()\n              .add(this.ec.keyFromPublic({ x: pubNonce.x, y: pubNonce.y }).getPublic())\n          }\n        } else {\n          throw new Error('getOrSetNonce should always return typeOfUser.')\n        }\n      } else {\n        typeOfUser = 'v1'\n        nonce = await this.getMetadata({ pub_key_X: X, pub_key_Y: Y })\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n      }\n\n      X = modifiedPubKey.getX().toString(16)\n      Y = modifiedPubKey.getY().toString(16)\n\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY())\n      log.debug('> torus.js/getPublicAddress', { X, Y, address, typeOfUser, nonce: nonce?.toString(16), pubNonce })\n\n      if (!isExtended) return address\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce,\n      }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n  }\n\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError\n  }\n\n  async getOrSetNonce(X, Y, privKey, getOnly = false) {\n    let data\n    const msg = getOnly ? 'getNonce' : 'getOrSetNonce'\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey)\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: { data: msg },\n      }\n    }\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, { useAPIKey: true })\n  }\n\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true)\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16)\n    const nonceBN = new BN(nonce, 16)\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString('hex')\n  }\n}\n\nexport default Torus\n","import Torus from './torus'\n\nexport { keyAssign, keyLookup, waitKeyLookup } from './utils'\n\nexport default Torus\n"],"sourceRoot":""}